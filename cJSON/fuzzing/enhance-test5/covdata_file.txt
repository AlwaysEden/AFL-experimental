/home/s22100141/AFLplusplus-experimental/cJSON/cJSON.c:
    1|       |/*
    2|       |  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
    3|       |
    4|       |  Permission is hereby granted, free of charge, to any person obtaining a copy
    5|       |  of this software and associated documentation files (the "Software"), to deal
    6|       |  in the Software without restriction, including without limitation the rights
    7|       |  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    8|       |  copies of the Software, and to permit persons to whom the Software is
    9|       |  furnished to do so, subject to the following conditions:
   10|       |
   11|       |  The above copyright notice and this permission notice shall be included in
   12|       |  all copies or substantial portions of the Software.
   13|       |
   14|       |  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   15|       |  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   16|       |  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   17|       |  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   18|       |  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   19|       |  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   20|       |  THE SOFTWARE.
   21|       |*/
   22|       |
   23|       |/* cJSON */
   24|       |/* JSON parser in C. */
   25|       |
   26|       |/* disable warnings about old C89 functions in MSVC */
   27|       |#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
   28|       |#define _CRT_SECURE_NO_DEPRECATE
   29|       |#endif
   30|       |
   31|       |#ifdef __GNUC__
   32|       |#pragma GCC visibility push(default)
   33|       |#endif
   34|       |#if defined(_MSC_VER)
   35|       |#pragma warning (push)
   36|       |/* disable warning about single line comments in system headers */
   37|       |#pragma warning (disable : 4001)
   38|       |#endif
   39|       |
   40|       |#include <string.h>
   41|       |#include <stdio.h>
   42|       |#include <math.h>
   43|       |#include <stdlib.h>
   44|       |#include <limits.h>
   45|       |#include <ctype.h>
   46|       |#include <float.h>
   47|       |
   48|       |#ifdef ENABLE_LOCALES
   49|       |#include <locale.h>
   50|       |#endif
   51|       |
   52|       |#if defined(_MSC_VER)
   53|       |#pragma warning (pop)
   54|       |#endif
   55|       |#ifdef __GNUC__
   56|       |#pragma GCC visibility pop
   57|       |#endif
   58|       |
   59|       |#include "cJSON.h"
   60|       |
   61|       |/* define our own boolean type */
   62|       |#ifdef true
   63|       |#undef true
   64|       |#endif
   65|  67.9k|#define true ((cJSON_bool)1)
   66|       |
   67|       |#ifdef false
   68|       |#undef false
   69|       |#endif
   70|  7.03k|#define false ((cJSON_bool)0)
   71|       |
   72|       |/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */
   73|       |#ifndef isinf
   74|       |#define isinf(d) (isnan((d - d)) && !isnan(d))
   75|       |#endif
   76|       |#ifndef isnan
   77|       |#define isnan(d) (d != d)
   78|       |#endif
   79|       |
   80|       |#ifndef NAN
   81|       |#ifdef _WIN32
   82|       |#define NAN sqrt(-1.0)
   83|       |#else
   84|       |#define NAN 0.0/0.0
   85|       |#endif
   86|       |#endif
   87|       |
   88|       |typedef struct {
   89|       |    const unsigned char *json;
   90|       |    size_t position;
   91|       |} error;
   92|       |static error global_error = { NULL, 0 };
   93|       |
   94|       |CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
   95|      0|{
   96|      0|    return (const char*) (global_error.json + global_error.position);
   97|      0|}
   98|       |
   99|       |CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item)
  100|      0|{
  101|      0|    if (!cJSON_IsString(item))
  102|      0|    {
  103|      0|        return NULL;
  104|      0|    }
  105|       |
  106|      0|    return item->valuestring;
  107|      0|}
  108|       |
  109|       |CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)
  110|      0|{
  111|      0|    if (!cJSON_IsNumber(item))
  112|      0|    {
  113|      0|        return (double) NAN;
  114|      0|    }
  115|       |
  116|      0|    return item->valuedouble;
  117|      0|}
  118|       |
  119|       |/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
  120|       |#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 17)
  121|       |    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
  122|       |#endif
  123|       |
  124|       |CJSON_PUBLIC(const char*) cJSON_Version(void)
  125|      0|{
  126|      0|    static char version[15];
  127|      0|    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
  128|       |
  129|      0|    return version;
  130|      0|}
  131|       |
  132|       |/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
  133|       |static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
  134|      0|{
  135|      0|    if ((string1 == NULL) || (string2 == NULL))
  136|      0|    {
  137|      0|        return 1;
  138|      0|    }
  139|       |
  140|      0|    if (string1 == string2)
  141|      0|    {
  142|      0|        return 0;
  143|      0|    }
  144|       |
  145|      0|    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
  146|      0|    {
  147|      0|        if (*string1 == '\0')
  148|      0|        {
  149|      0|            return 0;
  150|      0|        }
  151|      0|    }
  152|       |
  153|      0|    return tolower(*string1) - tolower(*string2);
  154|      0|}
  155|       |
  156|       |typedef struct internal_hooks
  157|       |{
  158|       |    void *(CJSON_CDECL *allocate)(size_t size);
  159|       |    void (CJSON_CDECL *deallocate)(void *pointer);
  160|       |    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
  161|       |} internal_hooks;
  162|       |
  163|       |#if defined(_MSC_VER)
  164|       |/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
  165|       |static void * CJSON_CDECL internal_malloc(size_t size)
  166|       |{
  167|       |    return malloc(size);
  168|       |}
  169|       |static void CJSON_CDECL internal_free(void *pointer)
  170|       |{
  171|       |    free(pointer);
  172|       |}
  173|       |static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
  174|       |{
  175|       |    return realloc(pointer, size);
  176|       |}
  177|       |#else
  178|       |#define internal_malloc malloc
  179|       |#define internal_free free
  180|       |#define internal_realloc realloc
  181|       |#endif
  182|       |
  183|       |/* strlen of character literals resolved at compile time */
  184|      0|#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
  185|       |
  186|       |static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
  187|       |
  188|       |static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
  189|      0|{
  190|      0|    size_t length = 0;
  191|      0|    unsigned char *copy = NULL;
  192|       |
  193|      0|    if (string == NULL)
  194|      0|    {
  195|      0|        return NULL;
  196|      0|    }
  197|       |
  198|      0|    length = strlen((const char*)string) + sizeof("");
  199|      0|    copy = (unsigned char*)hooks->allocate(length);
  200|      0|    if (copy == NULL)
  201|      0|    {
  202|      0|        return NULL;
  203|      0|    }
  204|      0|    memcpy(copy, string, length);
  205|       |
  206|      0|    return copy;
  207|      0|}
  208|       |
  209|       |CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
  210|      0|{
  211|      0|    if (hooks == NULL)
  212|      0|    {
  213|       |        /* Reset hooks */
  214|      0|        global_hooks.allocate = malloc;
  215|      0|        global_hooks.deallocate = free;
  216|      0|        global_hooks.reallocate = realloc;
  217|      0|        return;
  218|      0|    }
  219|       |
  220|      0|    global_hooks.allocate = malloc;
  221|      0|    if (hooks->malloc_fn != NULL)
  222|      0|    {
  223|      0|        global_hooks.allocate = hooks->malloc_fn;
  224|      0|    }
  225|       |
  226|      0|    global_hooks.deallocate = free;
  227|      0|    if (hooks->free_fn != NULL)
  228|      0|    {
  229|      0|        global_hooks.deallocate = hooks->free_fn;
  230|      0|    }
  231|       |
  232|       |    /* use realloc only if both free and malloc are used */
  233|      0|    global_hooks.reallocate = NULL;
  234|      0|    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
  235|      0|    {
  236|      0|        global_hooks.reallocate = realloc;
  237|      0|    }
  238|      0|}
  239|       |
  240|       |/* Internal constructor. */
  241|       |static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
  242|  29.6k|{
  243|  29.6k|    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
  244|  29.6k|    if (node)
  245|  29.6k|    {
  246|  29.6k|        memset(node, '\0', sizeof(cJSON));
  247|  29.6k|    }
  248|       |
  249|  29.6k|    return node;
  250|  29.6k|}
  251|       |
  252|       |/* Delete a cJSON structure. */
  253|       |CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
  254|  12.5k|{
  255|  12.5k|    cJSON *next = NULL;
  256|  42.2k|    while (item != NULL)
  257|  29.6k|    {
  258|  29.6k|        next = item->next;
  259|  29.6k|        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
  260|  5.00k|        {
  261|  5.00k|            cJSON_Delete(item->child);
  262|  5.00k|        }
  263|  29.6k|        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
  264|  10.6k|        {
  265|  10.6k|            global_hooks.deallocate(item->valuestring);
  266|  10.6k|        }
  267|  29.6k|        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
  268|  15.3k|        {
  269|  15.3k|            global_hooks.deallocate(item->string);
  270|  15.3k|        }
  271|  29.6k|        global_hooks.deallocate(item);
  272|  29.6k|        item = next;
  273|  29.6k|    }
  274|  12.5k|}
  275|       |
  276|       |/* get the decimal point character of the current locale */
  277|       |static unsigned char get_decimal_point(void)
  278|  11.6k|{
  279|       |#ifdef ENABLE_LOCALES
  280|       |    struct lconv *lconv = localeconv();
  281|       |    return (unsigned char) lconv->decimal_point[0];
  282|       |#else
  283|  11.6k|    return '.';
  284|  11.6k|#endif
  285|  11.6k|}
  286|       |
  287|       |typedef struct
  288|       |{
  289|       |    const unsigned char *content;
  290|       |    size_t length;
  291|       |    size_t offset;
  292|       |    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
  293|       |    internal_hooks hooks;
  294|       |} parse_buffer;
  295|       |
  296|       |/* check if the given size is left to read in a given parse buffer (starting with 1) */
  297|   175k|#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
  298|       |/* check if the buffer can be accessed at the given index (starting with 0) */
  299|   784k|#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
  300|   168k|#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
  301|       |/* get a pointer to the buffer at the position */
  302|   629k|#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
  303|       |
  304|       |/* Parse the input text to generate a number, and populate the result into item. */
  305|       |static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
  306|  7.06k|{
  307|  7.06k|    double number = 0;
  308|  7.06k|    unsigned char *after_end = NULL;
  309|  7.06k|    unsigned char number_c_string[64];
  310|  7.06k|    unsigned char decimal_point = get_decimal_point();
  311|  7.06k|    size_t i = 0;
  312|       |
  313|  7.06k|    if ((input_buffer == NULL) || (input_buffer->content == NULL))
  314|      0|    {
  315|      0|        return false;
  316|      0|    }
  317|       |
  318|       |    /* copy the number into a temporary buffer and replace '.' with the decimal point
  319|       |     * of the current locale (for strtod)
  320|       |     * This also takes care of '\0' not necessarily being available for marking the end of the input */
  321|  39.5k|    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
  322|  39.5k|    {
  323|  39.5k|        switch (buffer_at_offset(input_buffer)[i])
  324|  39.5k|        {
  325|  5.68k|            case '0':
  326|  9.67k|            case '1':
  327|  24.8k|            case '2':
  328|  25.6k|            case '3':
  329|  25.8k|            case '4':
  330|  26.9k|            case '5':
  331|  27.6k|            case '6':
  332|  28.3k|            case '7':
  333|  28.7k|            case '8':
  334|  29.5k|            case '9':
  335|  29.5k|            case '+':
  336|  30.8k|            case '-':
  337|  31.2k|            case 'e':
  338|  31.2k|            case 'E':
  339|  31.2k|                number_c_string[i] = buffer_at_offset(input_buffer)[i];
  340|  31.2k|                break;
  341|       |
  342|  1.26k|            case '.':
  343|  1.26k|                number_c_string[i] = decimal_point;
  344|  1.26k|                break;
  345|       |
  346|  7.05k|            default:
  347|  7.05k|                goto loop_end;
  348|  39.5k|        }
  349|  39.5k|    }
  350|  7.06k|loop_end:
  351|  7.06k|    number_c_string[i] = '\0';
  352|       |
  353|  7.06k|    number = strtod((const char*)number_c_string, (char**)&after_end);
  354|  7.06k|    if (number_c_string == after_end)
  355|     41|    {
  356|     41|        return false; /* parse_error */
  357|     41|    }
  358|       |
  359|  7.02k|    item->valuedouble = number;
  360|       |
  361|       |    /* use saturation in case of overflow */
  362|  7.02k|    if (number >= INT_MAX)
  363|  1.01k|    {
  364|  1.01k|        item->valueint = INT_MAX;
  365|  1.01k|    }
  366|  6.00k|    else if (number <= (double)INT_MIN)
  367|     50|    {
  368|     50|        item->valueint = INT_MIN;
  369|     50|    }
  370|  5.95k|    else
  371|  5.95k|    {
  372|  5.95k|        item->valueint = (int)number;
  373|  5.95k|    }
  374|       |
  375|  7.02k|    item->type = cJSON_Number;
  376|       |
  377|  7.02k|    input_buffer->offset += (size_t)(after_end - number_c_string);
  378|  7.02k|    return true;
  379|  7.06k|}
  380|       |
  381|       |/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
  382|       |CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
  383|      0|{
  384|      0|    if (number >= INT_MAX)
  385|      0|    {
  386|      0|        object->valueint = INT_MAX;
  387|      0|    }
  388|      0|    else if (number <= (double)INT_MIN)
  389|      0|    {
  390|      0|        object->valueint = INT_MIN;
  391|      0|    }
  392|      0|    else
  393|      0|    {
  394|      0|        object->valueint = (int)number;
  395|      0|    }
  396|       |
  397|      0|    return object->valuedouble = number;
  398|      0|}
  399|       |
  400|       |/* Note: when passing a NULL valuestring, cJSON_SetValuestring treats this as an error and return NULL */
  401|       |CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)
  402|      0|{
  403|      0|    char *copy = NULL;
  404|       |    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */
  405|      0|    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))
  406|      0|    {
  407|      0|        return NULL;
  408|      0|    }
  409|       |    /* return NULL if the object is corrupted or valuestring is NULL */
  410|      0|    if (object->valuestring == NULL || valuestring == NULL)
  411|      0|    {
  412|      0|        return NULL;
  413|      0|    }
  414|      0|    if (strlen(valuestring) <= strlen(object->valuestring))
  415|      0|    {
  416|      0|        strcpy(object->valuestring, valuestring);
  417|      0|        return object->valuestring;
  418|      0|    }
  419|      0|    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);
  420|      0|    if (copy == NULL)
  421|      0|    {
  422|      0|        return NULL;
  423|      0|    }
  424|      0|    if (object->valuestring != NULL)
  425|      0|    {
  426|      0|        cJSON_free(object->valuestring);
  427|      0|    }
  428|      0|    object->valuestring = copy;
  429|       |
  430|      0|    return copy;
  431|      0|}
  432|       |
  433|       |typedef struct
  434|       |{
  435|       |    unsigned char *buffer;
  436|       |    size_t length;
  437|       |    size_t offset;
  438|       |    size_t depth; /* current nesting depth (for formatted printing) */
  439|       |    cJSON_bool noalloc;
  440|       |    cJSON_bool format; /* is this print a formatted print */
  441|       |    internal_hooks hooks;
  442|       |} printbuffer;
  443|       |
  444|       |/* realloc printbuffer if necessary to have at least "needed" bytes more */
  445|       |static unsigned char* ensure(printbuffer * const p, size_t needed)
  446|  69.1k|{
  447|  69.1k|    unsigned char *newbuffer = NULL;
  448|  69.1k|    size_t newsize = 0;
  449|       |
  450|  69.1k|    if ((p == NULL) || (p->buffer == NULL))
  451|      0|    {
  452|      0|        return NULL;
  453|      0|    }
  454|       |
  455|  69.1k|    if ((p->length > 0) && (p->offset >= p->length))
  456|      0|    {
  457|       |        /* make sure that offset is valid */
  458|      0|        return NULL;
  459|      0|    }
  460|       |
  461|  69.1k|    if (needed > INT_MAX)
  462|      0|    {
  463|       |        /* sizes bigger than INT_MAX are currently not supported */
  464|      0|        return NULL;
  465|      0|    }
  466|       |
  467|  69.1k|    needed += p->offset + 1;
  468|  69.1k|    if (needed <= p->length)
  469|  65.8k|    {
  470|  65.8k|        return p->buffer + p->offset;
  471|  65.8k|    }
  472|       |
  473|  3.28k|    if (p->noalloc) {
  474|      0|        return NULL;
  475|      0|    }
  476|       |
  477|       |    /* calculate new buffer size */
  478|  3.28k|    if (needed > (INT_MAX / 2))
  479|      0|    {
  480|       |        /* overflow of int, use INT_MAX if possible */
  481|      0|        if (needed <= INT_MAX)
  482|      0|        {
  483|      0|            newsize = INT_MAX;
  484|      0|        }
  485|      0|        else
  486|      0|        {
  487|      0|            return NULL;
  488|      0|        }
  489|      0|    }
  490|  3.28k|    else
  491|  3.28k|    {
  492|  3.28k|        newsize = needed * 2;
  493|  3.28k|    }
  494|       |
  495|  3.28k|    if (p->hooks.reallocate != NULL)
  496|  3.28k|    {
  497|       |        /* reallocate with realloc if available */
  498|  3.28k|        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
  499|  3.28k|        if (newbuffer == NULL)
  500|      0|        {
  501|      0|            p->hooks.deallocate(p->buffer);
  502|      0|            p->length = 0;
  503|      0|            p->buffer = NULL;
  504|       |
  505|      0|            return NULL;
  506|      0|        }
  507|  3.28k|    }
  508|      0|    else
  509|      0|    {
  510|       |        /* otherwise reallocate manually */
  511|      0|        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
  512|      0|        if (!newbuffer)
  513|      0|        {
  514|      0|            p->hooks.deallocate(p->buffer);
  515|      0|            p->length = 0;
  516|      0|            p->buffer = NULL;
  517|       |
  518|      0|            return NULL;
  519|      0|        }
  520|       |
  521|      0|        memcpy(newbuffer, p->buffer, p->offset + 1);
  522|      0|        p->hooks.deallocate(p->buffer);
  523|      0|    }
  524|  3.28k|    p->length = newsize;
  525|  3.28k|    p->buffer = newbuffer;
  526|       |
  527|  3.28k|    return newbuffer + p->offset;
  528|  3.28k|}
  529|       |
  530|       |/* calculate the new length of the string in a printbuffer and update the offset */
  531|       |static void update_offset(printbuffer * const buffer)
  532|  28.1k|{
  533|  28.1k|    const unsigned char *buffer_pointer = NULL;
  534|  28.1k|    if ((buffer == NULL) || (buffer->buffer == NULL))
  535|      0|    {
  536|      0|        return;
  537|      0|    }
  538|  28.1k|    buffer_pointer = buffer->buffer + buffer->offset;
  539|       |
  540|  28.1k|    buffer->offset += strlen((const char*)buffer_pointer);
  541|  28.1k|}
  542|       |
  543|       |/* securely comparison of floating-point variables */
  544|       |static cJSON_bool compare_double(double a, double b)
  545|  1.25k|{
  546|  1.25k|    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
  547|  1.25k|    return (fabs(a - b) <= maxVal * DBL_EPSILON);
  548|  1.25k|}
  549|       |
  550|       |/* Render the number nicely from the given item into a string. */
  551|       |static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
  552|  4.61k|{
  553|  4.61k|    unsigned char *output_pointer = NULL;
  554|  4.61k|    double d = item->valuedouble;
  555|  4.61k|    int length = 0;
  556|  4.61k|    size_t i = 0;
  557|  4.61k|    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
  558|  4.61k|    unsigned char decimal_point = get_decimal_point();
  559|  4.61k|    double test = 0.0;
  560|       |
  561|  4.61k|    if (output_buffer == NULL)
  562|      0|    {
  563|      0|        return false;
  564|      0|    }
  565|       |
  566|       |    /* This checks for NaN and Infinity */
  567|  4.61k|    if (isnan(d) || isinf(d))
  568|     16|    {
  569|     16|        length = sprintf((char*)number_buffer, "null");
  570|     16|    }
  571|  4.59k|	else if(d == (double)item->valueint)
  572|  3.33k|	{
  573|  3.33k|		length = sprintf((char*)number_buffer, "%d", item->valueint);
  574|  3.33k|	}
  575|  1.25k|    else
  576|  1.25k|    {
  577|       |        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
  578|  1.25k|        length = sprintf((char*)number_buffer, "%1.15g", d);
  579|       |
  580|       |        /* Check whether the original double can be recovered */
  581|  1.25k|        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
  582|    408|        {
  583|       |            /* If not, print with 17 decimal places of precision */
  584|    408|            length = sprintf((char*)number_buffer, "%1.17g", d);
  585|    408|        }
  586|  1.25k|    }
  587|       |
  588|       |    /* sprintf failed or buffer overrun occurred */
  589|  4.61k|    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
  590|      0|    {
  591|      0|        return false;
  592|      0|    }
  593|       |
  594|       |    /* reserve appropriate space in the output */
  595|  4.61k|    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
  596|  4.61k|    if (output_pointer == NULL)
  597|      0|    {
  598|      0|        return false;
  599|      0|    }
  600|       |
  601|       |    /* copy the printed number to the output and replace locale
  602|       |     * dependent decimal point with '.' */
  603|  29.1k|    for (i = 0; i < ((size_t)length); i++)
  604|  24.5k|    {
  605|  24.5k|        if (number_buffer[i] == decimal_point)
  606|    712|        {
  607|    712|            output_pointer[i] = '.';
  608|    712|            continue;
  609|    712|        }
  610|       |
  611|  23.8k|        output_pointer[i] = number_buffer[i];
  612|  23.8k|    }
  613|  4.61k|    output_pointer[i] = '\0';
  614|       |
  615|  4.61k|    output_buffer->offset += (size_t)length;
  616|       |
  617|  4.61k|    return true;
  618|  4.61k|}
  619|       |
  620|       |/* parse 4 digit hexadecimal number */
  621|       |static unsigned parse_hex4(const unsigned char * const input)
  622|  10.4k|{
  623|  10.4k|    unsigned int h = 0;
  624|  10.4k|    size_t i = 0;
  625|       |
  626|  36.5k|    for (i = 0; i < 4; i++)
  627|  35.0k|    {
  628|       |        /* parse digit */
  629|  35.0k|        if ((input[i] >= '0') && (input[i] <= '9'))
  630|  2.02k|        {
  631|  2.02k|            h += (unsigned int) input[i] - '0';
  632|  2.02k|        }
  633|  33.0k|        else if ((input[i] >= 'A') && (input[i] <= 'F'))
  634|  8.95k|        {
  635|  8.95k|            h += (unsigned int) 10 + input[i] - 'A';
  636|  8.95k|        }
  637|  24.0k|        else if ((input[i] >= 'a') && (input[i] <= 'f'))
  638|  15.0k|        {
  639|  15.0k|            h += (unsigned int) 10 + input[i] - 'a';
  640|  15.0k|        }
  641|  9.01k|        else /* invalid */
  642|  9.01k|        {
  643|  9.01k|            return 0;
  644|  9.01k|        }
  645|       |
  646|  26.0k|        if (i < 3)
  647|  24.6k|        {
  648|       |            /* shift left to make place for the next nibble */
  649|  24.6k|            h = h << 4;
  650|  24.6k|        }
  651|  26.0k|    }
  652|       |
  653|  1.43k|    return h;
  654|  10.4k|}
  655|       |
  656|       |/* converts a UTF-16 literal to UTF-8
  657|       | * A literal can be one or two sequences of the form \uXXXX */
  658|       |static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
  659|  10.0k|{
  660|  10.0k|    long unsigned int codepoint = 0;
  661|  10.0k|    unsigned int first_code = 0;
  662|  10.0k|    const unsigned char *first_sequence = input_pointer;
  663|  10.0k|    unsigned char utf8_length = 0;
  664|  10.0k|    unsigned char utf8_position = 0;
  665|  10.0k|    unsigned char sequence_length = 0;
  666|  10.0k|    unsigned char first_byte_mark = 0;
  667|       |
  668|  10.0k|    if ((input_end - first_sequence) < 6)
  669|      1|    {
  670|       |        /* input ends unexpectedly */
  671|      1|        goto fail;
  672|      1|    }
  673|       |
  674|       |    /* get the first utf16 sequence */
  675|  10.0k|    first_code = parse_hex4(first_sequence + 2);
  676|       |
  677|       |    /* check that the code is valid */
  678|  10.0k|    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
  679|      9|    {
  680|      9|        goto fail;
  681|      9|    }
  682|       |
  683|       |    /* UTF16 surrogate pair */
  684|  10.0k|    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
  685|    434|    {
  686|    434|        const unsigned char *second_sequence = first_sequence + 6;
  687|    434|        unsigned int second_code = 0;
  688|    434|        sequence_length = 12; /* \uXXXX\uXXXX */
  689|       |
  690|    434|        if ((input_end - second_sequence) < 6)
  691|     14|        {
  692|       |            /* input ends unexpectedly */
  693|     14|            goto fail;
  694|     14|        }
  695|       |
  696|    420|        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
  697|     28|        {
  698|       |            /* missing second half of the surrogate pair */
  699|     28|            goto fail;
  700|     28|        }
  701|       |
  702|       |        /* get the second utf16 sequence */
  703|    392|        second_code = parse_hex4(second_sequence + 2);
  704|       |        /* check that the code is valid */
  705|    392|        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
  706|     45|        {
  707|       |            /* invalid second half of the surrogate pair */
  708|     45|            goto fail;
  709|     45|        }
  710|       |
  711|       |
  712|       |        /* calculate the unicode codepoint from the surrogate pair */
  713|    347|        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
  714|    347|    }
  715|  9.61k|    else
  716|  9.61k|    {
  717|  9.61k|        sequence_length = 6; /* \uXXXX */
  718|  9.61k|        codepoint = first_code;
  719|  9.61k|    }
  720|       |
  721|       |    /* encode as UTF-8
  722|       |     * takes at maximum 4 bytes to encode:
  723|       |     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
  724|  9.96k|    if (codepoint < 0x80)
  725|  8.98k|    {
  726|       |        /* normal ascii, encoding 0xxxxxxx */
  727|  8.98k|        utf8_length = 1;
  728|  8.98k|    }
  729|    979|    else if (codepoint < 0x800)
  730|    157|    {
  731|       |        /* two bytes, encoding 110xxxxx 10xxxxxx */
  732|    157|        utf8_length = 2;
  733|    157|        first_byte_mark = 0xC0; /* 11000000 */
  734|    157|    }
  735|    822|    else if (codepoint < 0x10000)
  736|    475|    {
  737|       |        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
  738|    475|        utf8_length = 3;
  739|    475|        first_byte_mark = 0xE0; /* 11100000 */
  740|    475|    }
  741|    347|    else if (codepoint <= 0x10FFFF)
  742|    347|    {
  743|       |        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
  744|    347|        utf8_length = 4;
  745|    347|        first_byte_mark = 0xF0; /* 11110000 */
  746|    347|    }
  747|      0|    else
  748|      0|    {
  749|       |        /* invalid unicode codepoint */
  750|      0|        goto fail;
  751|      0|    }
  752|       |
  753|       |    /* encode as utf8 */
  754|  12.1k|    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
  755|  2.14k|    {
  756|       |        /* 10xxxxxx */
  757|  2.14k|        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
  758|  2.14k|        codepoint >>= 6;
  759|  2.14k|    }
  760|       |    /* encode first byte */
  761|  9.96k|    if (utf8_length > 1)
  762|    979|    {
  763|    979|        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
  764|    979|    }
  765|  8.98k|    else
  766|  8.98k|    {
  767|  8.98k|        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
  768|  8.98k|    }
  769|       |
  770|  9.96k|    *output_pointer += utf8_length;
  771|       |
  772|  9.96k|    return sequence_length;
  773|       |
  774|     97|fail:
  775|     97|    return 0;
  776|  9.96k|}
  777|       |
  778|       |/* Parse the input text into an unescaped cinput, and populate item. */
  779|       |static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
  780|  26.3k|{
  781|  26.3k|    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
  782|  26.3k|    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
  783|  26.3k|    unsigned char *output_pointer = NULL;
  784|  26.3k|    unsigned char *output = NULL;
  785|       |
  786|       |    /* not a string */
  787|  26.3k|    if (buffer_at_offset(input_buffer)[0] != '\"')
  788|     54|    {
  789|     54|        goto fail;
  790|     54|    }
  791|       |
  792|  26.2k|    {
  793|       |        /* calculate approximate size of the output (overestimate) */
  794|  26.2k|        size_t allocation_length = 0;
  795|  26.2k|        size_t skipped_bytes = 0;
  796|   444k|        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
  797|   418k|        {
  798|       |            /* is escape sequence */
  799|   418k|            if (input_end[0] == '\\')
  800|  21.8k|            {
  801|  21.8k|                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
  802|      0|                {
  803|       |                    /* prevent buffer overflow when last input character is a backslash */
  804|      0|                    goto fail;
  805|      0|                }
  806|  21.8k|                skipped_bytes++;
  807|  21.8k|                input_end++;
  808|  21.8k|            }
  809|   418k|            input_end++;
  810|   418k|        }
  811|  26.2k|        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
  812|     45|        {
  813|     45|            goto fail; /* string ended unexpectedly */
  814|     45|        }
  815|       |
  816|       |        /* This is at most how much we need for the output */
  817|  26.2k|        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
  818|  26.2k|        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
  819|  26.2k|        if (output == NULL)
  820|      0|        {
  821|      0|            goto fail; /* allocation failure */
  822|      0|        }
  823|  26.2k|    }
  824|       |
  825|  26.2k|    output_pointer = output;
  826|       |    /* loop through the string literal */
  827|   398k|    while (input_pointer < input_end)
  828|   372k|    {
  829|   372k|        if (*input_pointer != '\\')
  830|   353k|        {
  831|   353k|            *output_pointer++ = *input_pointer++;
  832|   353k|        }
  833|       |        /* escape sequence */
  834|  19.4k|        else
  835|  19.4k|        {
  836|  19.4k|            unsigned char sequence_length = 2;
  837|  19.4k|            if ((input_end - input_pointer) < 1)
  838|      0|            {
  839|      0|                goto fail;
  840|      0|            }
  841|       |
  842|  19.4k|            switch (input_pointer[1])
  843|  19.4k|            {
  844|     76|                case 'b':
  845|     76|                    *output_pointer++ = '\b';
  846|     76|                    break;
  847|    132|                case 'f':
  848|    132|                    *output_pointer++ = '\f';
  849|    132|                    break;
  850|    355|                case 'n':
  851|    355|                    *output_pointer++ = '\n';
  852|    355|                    break;
  853|     99|                case 'r':
  854|     99|                    *output_pointer++ = '\r';
  855|     99|                    break;
  856|    185|                case 't':
  857|    185|                    *output_pointer++ = '\t';
  858|    185|                    break;
  859|    531|                case '\"':
  860|  8.39k|                case '\\':
  861|  8.40k|                case '/':
  862|  8.40k|                    *output_pointer++ = input_pointer[1];
  863|  8.40k|                    break;
  864|       |
  865|       |                /* UTF-16 literal */
  866|  10.0k|                case 'u':
  867|  10.0k|                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
  868|  10.0k|                    if (sequence_length == 0)
  869|     97|                    {
  870|       |                        /* failed to convert UTF16-literal to UTF-8 */
  871|     97|                        goto fail;
  872|     97|                    }
  873|  9.96k|                    break;
  874|       |
  875|  9.96k|                default:
  876|     97|                    goto fail;
  877|  19.4k|            }
  878|  19.2k|            input_pointer += sequence_length;
  879|  19.2k|        }
  880|   372k|    }
  881|       |
  882|       |    /* zero terminate the output */
  883|  26.0k|    *output_pointer = '\0';
  884|       |
  885|  26.0k|    item->type = cJSON_String;
  886|  26.0k|    item->valuestring = (char*)output;
  887|       |
  888|  26.0k|    input_buffer->offset = (size_t) (input_end - input_buffer->content);
  889|  26.0k|    input_buffer->offset++;
  890|       |
  891|  26.0k|    return true;
  892|       |
  893|    293|fail:
  894|    293|    if (output != NULL)
  895|    194|    {
  896|    194|        input_buffer->hooks.deallocate(output);
  897|    194|    }
  898|       |
  899|    293|    if (input_pointer != NULL)
  900|    293|    {
  901|    293|        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
  902|    293|    }
  903|       |
  904|    293|    return false;
  905|  26.2k|}
  906|       |
  907|       |/* Render the cstring provided to an escaped version that can be printed. */
  908|       |static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
  909|  19.6k|{
  910|  19.6k|    const unsigned char *input_pointer = NULL;
  911|  19.6k|    unsigned char *output = NULL;
  912|  19.6k|    unsigned char *output_pointer = NULL;
  913|  19.6k|    size_t output_length = 0;
  914|       |    /* numbers of additional characters needed for escaping */
  915|  19.6k|    size_t escape_characters = 0;
  916|       |
  917|  19.6k|    if (output_buffer == NULL)
  918|      0|    {
  919|      0|        return false;
  920|      0|    }
  921|       |
  922|       |    /* empty string */
  923|  19.6k|    if (input == NULL)
  924|      0|    {
  925|      0|        output = ensure(output_buffer, sizeof("\"\""));
  926|      0|        if (output == NULL)
  927|      0|        {
  928|      0|            return false;
  929|      0|        }
  930|      0|        strcpy((char*)output, "\"\"");
  931|       |
  932|      0|        return true;
  933|      0|    }
  934|       |
  935|       |    /* set "flag" to 1 if something needs to be escaped */
  936|   266k|    for (input_pointer = input; *input_pointer; input_pointer++)
  937|   247k|    {
  938|   247k|        switch (*input_pointer)
  939|   247k|        {
  940|    329|            case '\"':
  941|  6.15k|            case '\\':
  942|  6.18k|            case '\b':
  943|  6.31k|            case '\f':
  944|  7.36k|            case '\n':
  945|  7.43k|            case '\r':
  946|  8.08k|            case '\t':
  947|       |                /* one character escape sequence */
  948|  8.08k|                escape_characters++;
  949|  8.08k|                break;
  950|   239k|            default:
  951|   239k|                if (*input_pointer < 32)
  952|  3.80k|                {
  953|       |                    /* UTF-16 escape sequence uXXXX */
  954|  3.80k|                    escape_characters += 5;
  955|  3.80k|                }
  956|   239k|                break;
  957|   247k|        }
  958|   247k|    }
  959|  19.6k|    output_length = (size_t)(input_pointer - input) + escape_characters;
  960|       |
  961|  19.6k|    output = ensure(output_buffer, output_length + sizeof("\"\""));
  962|  19.6k|    if (output == NULL)
  963|      0|    {
  964|      0|        return false;
  965|      0|    }
  966|       |
  967|       |    /* no characters have to be escaped */
  968|  19.6k|    if (escape_characters == 0)
  969|  18.9k|    {
  970|  18.9k|        output[0] = '\"';
  971|  18.9k|        memcpy(output + 1, input, output_length);
  972|  18.9k|        output[output_length + 1] = '\"';
  973|  18.9k|        output[output_length + 2] = '\0';
  974|       |
  975|  18.9k|        return true;
  976|  18.9k|    }
  977|       |
  978|    719|    output[0] = '\"';
  979|    719|    output_pointer = output + 1;
  980|       |    /* copy the string */
  981|  23.7k|    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
  982|  23.0k|    {
  983|  23.0k|        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
  984|  11.1k|        {
  985|       |            /* normal character, copy */
  986|  11.1k|            *output_pointer = *input_pointer;
  987|  11.1k|        }
  988|  11.8k|        else
  989|  11.8k|        {
  990|       |            /* character needs to be escaped */
  991|  11.8k|            *output_pointer++ = '\\';
  992|  11.8k|            switch (*input_pointer)
  993|  11.8k|            {
  994|  5.82k|                case '\\':
  995|  5.82k|                    *output_pointer = '\\';
  996|  5.82k|                    break;
  997|    329|                case '\"':
  998|    329|                    *output_pointer = '\"';
  999|    329|                    break;
 1000|     32|                case '\b':
 1001|     32|                    *output_pointer = 'b';
 1002|     32|                    break;
 1003|    134|                case '\f':
 1004|    134|                    *output_pointer = 'f';
 1005|    134|                    break;
 1006|  1.04k|                case '\n':
 1007|  1.04k|                    *output_pointer = 'n';
 1008|  1.04k|                    break;
 1009|     69|                case '\r':
 1010|     69|                    *output_pointer = 'r';
 1011|     69|                    break;
 1012|    647|                case '\t':
 1013|    647|                    *output_pointer = 't';
 1014|    647|                    break;
 1015|  3.80k|                default:
 1016|       |                    /* escape and print as unicode codepoint */
 1017|  3.80k|                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
 1018|  3.80k|                    output_pointer += 4;
 1019|  3.80k|                    break;
 1020|  11.8k|            }
 1021|  11.8k|        }
 1022|  23.0k|    }
 1023|    719|    output[output_length + 1] = '\"';
 1024|    719|    output[output_length + 2] = '\0';
 1025|       |
 1026|    719|    return true;
 1027|    719|}
 1028|       |
 1029|       |/* Invoke print_string_ptr (which is useful) on an item. */
 1030|       |static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
 1031|  8.13k|{
 1032|  8.13k|    return print_string_ptr((unsigned char*)item->valuestring, p);
 1033|  8.13k|}
 1034|       |
 1035|       |/* Predeclare these prototypes. */
 1036|       |static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
 1037|       |static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
 1038|       |static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
 1039|       |static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
 1040|       |static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
 1041|       |static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
 1042|       |
 1043|       |/* Utility to jump whitespace and cr/lf */
 1044|       |static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
 1045|  93.4k|{
 1046|  93.4k|    if ((buffer == NULL) || (buffer->content == NULL))
 1047|      0|    {
 1048|      0|        return NULL;
 1049|      0|    }
 1050|       |
 1051|  93.4k|    if (cannot_access_at_index(buffer, 0))
 1052|      0|    {
 1053|      0|        return buffer;
 1054|      0|    }
 1055|       |
 1056|   204k|    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
 1057|   110k|    {
 1058|   110k|       buffer->offset++;
 1059|   110k|    }
 1060|       |
 1061|  93.4k|    if (buffer->offset == buffer->length)
 1062|    125|    {
 1063|    125|        buffer->offset--;
 1064|    125|    }
 1065|       |
 1066|  93.4k|    return buffer;
 1067|  93.4k|}
 1068|       |
 1069|       |/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
 1070|       |static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
 1071|  2.01k|{
 1072|  2.01k|    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
 1073|      0|    {
 1074|      0|        return NULL;
 1075|      0|    }
 1076|       |
 1077|  2.01k|    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
 1078|      0|    {
 1079|      0|        buffer->offset += 3;
 1080|      0|    }
 1081|       |
 1082|  2.01k|    return buffer;
 1083|  2.01k|}
 1084|       |
 1085|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
 1086|  2.01k|{
 1087|  2.01k|    size_t buffer_length;
 1088|       |
 1089|  2.01k|    if (NULL == value)
 1090|      0|    {
 1091|      0|        return NULL;
 1092|      0|    }
 1093|       |
 1094|       |    /* Adding null character size due to require_null_terminated. */
 1095|  2.01k|    buffer_length = strlen(value) + sizeof("");
 1096|       |
 1097|  2.01k|    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);
 1098|  2.01k|}
 1099|       |
 1100|       |/* Parse an object - create a new root, and populate. */
 1101|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
 1102|  2.01k|{
 1103|  2.01k|    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
 1104|  2.01k|    cJSON *item = NULL;
 1105|       |
 1106|       |    /* reset error position */
 1107|  2.01k|    global_error.json = NULL;
 1108|  2.01k|    global_error.position = 0;
 1109|       |
 1110|  2.01k|    if (value == NULL || 0 == buffer_length)
 1111|      0|    {
 1112|      0|        goto fail;
 1113|      0|    }
 1114|       |
 1115|  2.01k|    buffer.content = (const unsigned char*)value;
 1116|  2.01k|    buffer.length = buffer_length;
 1117|  2.01k|    buffer.offset = 0;
 1118|  2.01k|    buffer.hooks = global_hooks;
 1119|       |
 1120|  2.01k|    item = cJSON_New_Item(&global_hooks);
 1121|  2.01k|    if (item == NULL) /* memory fail */
 1122|      0|    {
 1123|      0|        goto fail;
 1124|      0|    }
 1125|       |
 1126|  2.01k|    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
 1127|    947|    {
 1128|       |        /* parse failure. ep is set. */
 1129|    947|        goto fail;
 1130|    947|    }
 1131|       |
 1132|       |    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
 1133|  1.06k|    if (require_null_terminated)
 1134|      0|    {
 1135|      0|        buffer_skip_whitespace(&buffer);
 1136|      0|        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
 1137|      0|        {
 1138|      0|            goto fail;
 1139|      0|        }
 1140|      0|    }
 1141|  1.06k|    if (return_parse_end)
 1142|      0|    {
 1143|      0|        *return_parse_end = (const char*)buffer_at_offset(&buffer);
 1144|      0|    }
 1145|       |
 1146|  1.06k|    return item;
 1147|       |
 1148|    947|fail:
 1149|    947|    if (item != NULL)
 1150|    947|    {
 1151|    947|        cJSON_Delete(item);
 1152|    947|    }
 1153|       |
 1154|    947|    if (value != NULL)
 1155|    947|    {
 1156|    947|        error local_error;
 1157|    947|        local_error.json = (const unsigned char*)value;
 1158|    947|        local_error.position = 0;
 1159|       |
 1160|    947|        if (buffer.offset < buffer.length)
 1161|    935|        {
 1162|    935|            local_error.position = buffer.offset;
 1163|    935|        }
 1164|     12|        else if (buffer.length > 0)
 1165|     12|        {
 1166|     12|            local_error.position = buffer.length - 1;
 1167|     12|        }
 1168|       |
 1169|    947|        if (return_parse_end != NULL)
 1170|      0|        {
 1171|      0|            *return_parse_end = (const char*)local_error.json + local_error.position;
 1172|      0|        }
 1173|       |
 1174|    947|        global_error = local_error;
 1175|    947|    }
 1176|       |
 1177|    947|    return NULL;
 1178|  1.06k|}
 1179|       |
 1180|       |/* Default options for cJSON_Parse */
 1181|       |CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
 1182|  2.01k|{
 1183|  2.01k|    return cJSON_ParseWithOpts(value, 0, 0);
 1184|  2.01k|}
 1185|       |
 1186|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length)
 1187|      0|{
 1188|      0|    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);
 1189|      0|}
 1190|       |
 1191|      0|#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))
 1192|       |
 1193|       |static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
 1194|    267|{
 1195|    267|    static const size_t default_buffer_size = 256;
 1196|    267|    printbuffer buffer[1];
 1197|    267|    unsigned char *printed = NULL;
 1198|       |
 1199|    267|    memset(buffer, 0, sizeof(buffer));
 1200|       |
 1201|       |    /* create buffer */
 1202|    267|    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
 1203|    267|    buffer->length = default_buffer_size;
 1204|    267|    buffer->format = format;
 1205|    267|    buffer->hooks = *hooks;
 1206|    267|    if (buffer->buffer == NULL)
 1207|      0|    {
 1208|      0|        goto fail;
 1209|      0|    }
 1210|       |
 1211|       |    /* print the value */
 1212|    267|    if (!print_value(item, buffer))
 1213|      0|    {
 1214|      0|        goto fail;
 1215|      0|    }
 1216|    267|    update_offset(buffer);
 1217|       |
 1218|       |    /* check if reallocate is available */
 1219|    267|    if (hooks->reallocate != NULL)
 1220|    267|    {
 1221|    267|        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
 1222|    267|        if (printed == NULL) {
 1223|      0|            goto fail;
 1224|      0|        }
 1225|    267|        buffer->buffer = NULL;
 1226|    267|    }
 1227|      0|    else /* otherwise copy the JSON over to a new buffer */
 1228|      0|    {
 1229|      0|        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
 1230|      0|        if (printed == NULL)
 1231|      0|        {
 1232|      0|            goto fail;
 1233|      0|        }
 1234|      0|        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
 1235|      0|        printed[buffer->offset] = '\0'; /* just to be sure */
 1236|       |
 1237|       |        /* free the buffer */
 1238|      0|        hooks->deallocate(buffer->buffer);
 1239|      0|    }
 1240|       |
 1241|    267|    return printed;
 1242|       |
 1243|      0|fail:
 1244|      0|    if (buffer->buffer != NULL)
 1245|      0|    {
 1246|      0|        hooks->deallocate(buffer->buffer);
 1247|      0|    }
 1248|       |
 1249|      0|    if (printed != NULL)
 1250|      0|    {
 1251|      0|        hooks->deallocate(printed);
 1252|      0|    }
 1253|       |
 1254|      0|    return NULL;
 1255|    267|}
 1256|       |
 1257|       |/* Render a cJSON item/entity/structure to text. */
 1258|       |CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
 1259|     27|{
 1260|     27|    return (char*)print(item, true, &global_hooks);
 1261|     27|}
 1262|       |
 1263|       |CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
 1264|    240|{
 1265|    240|    return (char*)print(item, false, &global_hooks);
 1266|    240|}
 1267|       |
 1268|       |CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
 1269|    798|{
 1270|    798|    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
 1271|       |
 1272|    798|    if (prebuffer < 0)
 1273|      0|    {
 1274|      0|        return NULL;
 1275|      0|    }
 1276|       |
 1277|    798|    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
 1278|    798|    if (!p.buffer)
 1279|      0|    {
 1280|      0|        return NULL;
 1281|      0|    }
 1282|       |
 1283|    798|    p.length = (size_t)prebuffer;
 1284|    798|    p.offset = 0;
 1285|    798|    p.noalloc = false;
 1286|    798|    p.format = fmt;
 1287|    798|    p.hooks = global_hooks;
 1288|       |
 1289|    798|    if (!print_value(item, &p))
 1290|      0|    {
 1291|      0|        global_hooks.deallocate(p.buffer);
 1292|      0|        return NULL;
 1293|      0|    }
 1294|       |
 1295|    798|    return (char*)p.buffer;
 1296|    798|}
 1297|       |
 1298|       |CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
 1299|      0|{
 1300|      0|    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
 1301|       |
 1302|      0|    if ((length < 0) || (buffer == NULL))
 1303|      0|    {
 1304|      0|        return false;
 1305|      0|    }
 1306|       |
 1307|      0|    p.buffer = (unsigned char*)buffer;
 1308|      0|    p.length = (size_t)length;
 1309|      0|    p.offset = 0;
 1310|      0|    p.noalloc = true;
 1311|      0|    p.format = format;
 1312|      0|    p.hooks = global_hooks;
 1313|       |
 1314|      0|    return print_value(item, &p);
 1315|      0|}
 1316|       |
 1317|       |/* Parser core - when encountering text, process appropriately. */
 1318|       |static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
 1319|  29.4k|{
 1320|  29.4k|    if ((input_buffer == NULL) || (input_buffer->content == NULL))
 1321|      0|    {
 1322|      0|        return false; /* no input */
 1323|      0|    }
 1324|       |
 1325|       |    /* parse the different types of values */
 1326|       |    /* null */
 1327|  29.4k|    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
 1328|    162|    {
 1329|    162|        item->type = cJSON_NULL;
 1330|    162|        input_buffer->offset += 4;
 1331|    162|        return true;
 1332|    162|    }
 1333|       |    /* false */
 1334|  29.2k|    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
 1335|    280|    {
 1336|    280|        item->type = cJSON_False;
 1337|    280|        input_buffer->offset += 5;
 1338|    280|        return true;
 1339|    280|    }
 1340|       |    /* true */
 1341|  29.0k|    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
 1342|    211|    {
 1343|    211|        item->type = cJSON_True;
 1344|    211|        item->valueint = 1;
 1345|    211|        input_buffer->offset += 4;
 1346|    211|        return true;
 1347|    211|    }
 1348|       |    /* string */
 1349|  28.8k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
 1350|  10.8k|    {
 1351|  10.8k|        return parse_string(item, input_buffer);
 1352|  10.8k|    }
 1353|       |    /* number */
 1354|  17.9k|    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
 1355|  7.06k|    {
 1356|  7.06k|        return parse_number(item, input_buffer);
 1357|  7.06k|    }
 1358|       |    /* array */
 1359|  10.8k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
 1360|  7.11k|    {
 1361|  7.11k|        return parse_array(item, input_buffer);
 1362|  7.11k|    }
 1363|       |    /* object */
 1364|  3.74k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
 1365|  3.61k|    {
 1366|  3.61k|        return parse_object(item, input_buffer);
 1367|  3.61k|    }
 1368|       |
 1369|    132|    return false;
 1370|  3.74k|}
 1371|       |
 1372|       |/* Render a value to text. */
 1373|       |static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
 1374|  17.4k|{
 1375|  17.4k|    unsigned char *output = NULL;
 1376|       |
 1377|  17.4k|    if ((item == NULL) || (output_buffer == NULL))
 1378|      0|    {
 1379|      0|        return false;
 1380|      0|    }
 1381|       |
 1382|  17.4k|    switch ((item->type) & 0xFF)
 1383|  17.4k|    {
 1384|    133|        case cJSON_NULL:
 1385|    133|            output = ensure(output_buffer, 5);
 1386|    133|            if (output == NULL)
 1387|      0|            {
 1388|      0|                return false;
 1389|      0|            }
 1390|    133|            strcpy((char*)output, "null");
 1391|    133|            return true;
 1392|       |
 1393|    209|        case cJSON_False:
 1394|    209|            output = ensure(output_buffer, 6);
 1395|    209|            if (output == NULL)
 1396|      0|            {
 1397|      0|                return false;
 1398|      0|            }
 1399|    209|            strcpy((char*)output, "false");
 1400|    209|            return true;
 1401|       |
 1402|    173|        case cJSON_True:
 1403|    173|            output = ensure(output_buffer, 5);
 1404|    173|            if (output == NULL)
 1405|      0|            {
 1406|      0|                return false;
 1407|      0|            }
 1408|    173|            strcpy((char*)output, "true");
 1409|    173|            return true;
 1410|       |
 1411|  4.61k|        case cJSON_Number:
 1412|  4.61k|            return print_number(item, output_buffer);
 1413|       |
 1414|      0|        case cJSON_Raw:
 1415|      0|        {
 1416|      0|            size_t raw_length = 0;
 1417|      0|            if (item->valuestring == NULL)
 1418|      0|            {
 1419|      0|                return false;
 1420|      0|            }
 1421|       |
 1422|      0|            raw_length = strlen(item->valuestring) + sizeof("");
 1423|      0|            output = ensure(output_buffer, raw_length);
 1424|      0|            if (output == NULL)
 1425|      0|            {
 1426|      0|                return false;
 1427|      0|            }
 1428|      0|            memcpy(output, item->valuestring, raw_length);
 1429|      0|            return true;
 1430|      0|        }
 1431|       |
 1432|  8.13k|        case cJSON_String:
 1433|  8.13k|            return print_string(item, output_buffer);
 1434|       |
 1435|  1.68k|        case cJSON_Array:
 1436|  1.68k|            return print_array(item, output_buffer);
 1437|       |
 1438|  2.51k|        case cJSON_Object:
 1439|  2.51k|            return print_object(item, output_buffer);
 1440|       |
 1441|      0|        default:
 1442|      0|            return false;
 1443|  17.4k|    }
 1444|  17.4k|}
 1445|       |
 1446|       |/* Build an array from input text. */
 1447|       |static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
 1448|  7.11k|{
 1449|  7.11k|    cJSON *head = NULL; /* head of the linked list */
 1450|  7.11k|    cJSON *current_item = NULL;
 1451|       |
 1452|  7.11k|    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
 1453|      2|    {
 1454|      2|        return false; /* to deeply nested */
 1455|      2|    }
 1456|  7.10k|    input_buffer->depth++;
 1457|       |
 1458|  7.10k|    if (buffer_at_offset(input_buffer)[0] != '[')
 1459|      0|    {
 1460|       |        /* not an array */
 1461|      0|        goto fail;
 1462|      0|    }
 1463|       |
 1464|  7.10k|    input_buffer->offset++;
 1465|  7.10k|    buffer_skip_whitespace(input_buffer);
 1466|  7.10k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
 1467|    121|    {
 1468|       |        /* empty array */
 1469|    121|        goto success;
 1470|    121|    }
 1471|       |
 1472|       |    /* check if we skipped to the end of the buffer */
 1473|  6.98k|    if (cannot_access_at_index(input_buffer, 0))
 1474|      0|    {
 1475|      0|        input_buffer->offset--;
 1476|      0|        goto fail;
 1477|      0|    }
 1478|       |
 1479|       |    /* step back to character in front of the first element */
 1480|  6.98k|    input_buffer->offset--;
 1481|       |    /* loop through the comma separated array elements */
 1482|  6.98k|    do
 1483|  12.2k|    {
 1484|       |        /* allocate next item */
 1485|  12.2k|        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
 1486|  12.2k|        if (new_item == NULL)
 1487|      0|        {
 1488|      0|            goto fail; /* allocation failure */
 1489|      0|        }
 1490|       |
 1491|       |        /* attach next item to list */
 1492|  12.2k|        if (head == NULL)
 1493|  6.98k|        {
 1494|       |            /* start the linked list */
 1495|  6.98k|            current_item = head = new_item;
 1496|  6.98k|        }
 1497|  5.23k|        else
 1498|  5.23k|        {
 1499|       |            /* add to the end and advance */
 1500|  5.23k|            current_item->next = new_item;
 1501|  5.23k|            new_item->prev = current_item;
 1502|  5.23k|            current_item = new_item;
 1503|  5.23k|        }
 1504|       |
 1505|       |        /* parse next value */
 1506|  12.2k|        input_buffer->offset++;
 1507|  12.2k|        buffer_skip_whitespace(input_buffer);
 1508|  12.2k|        if (!parse_value(current_item, input_buffer))
 1509|  4.56k|        {
 1510|  4.56k|            goto fail; /* failed to parse value */
 1511|  4.56k|        }
 1512|  7.66k|        buffer_skip_whitespace(input_buffer);
 1513|  7.66k|    }
 1514|  7.66k|    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
 1515|       |
 1516|  2.42k|    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
 1517|    183|    {
 1518|    183|        goto fail; /* expected end of array */
 1519|    183|    }
 1520|       |
 1521|  2.36k|success:
 1522|  2.36k|    input_buffer->depth--;
 1523|       |
 1524|  2.36k|    if (head != NULL) {
 1525|  2.24k|        head->prev = current_item;
 1526|  2.24k|    }
 1527|       |
 1528|  2.36k|    item->type = cJSON_Array;
 1529|  2.36k|    item->child = head;
 1530|       |
 1531|  2.36k|    input_buffer->offset++;
 1532|       |
 1533|  2.36k|    return true;
 1534|       |
 1535|  4.74k|fail:
 1536|  4.74k|    if (head != NULL)
 1537|  4.74k|    {
 1538|  4.74k|        cJSON_Delete(head);
 1539|  4.74k|    }
 1540|       |
 1541|  4.74k|    return false;
 1542|  2.42k|}
 1543|       |
 1544|       |/* Render an array to text */
 1545|       |static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
 1546|  1.68k|{
 1547|  1.68k|    unsigned char *output_pointer = NULL;
 1548|  1.68k|    size_t length = 0;
 1549|  1.68k|    cJSON *current_element = item->child;
 1550|       |
 1551|  1.68k|    if (output_buffer == NULL)
 1552|      0|    {
 1553|      0|        return false;
 1554|      0|    }
 1555|       |
 1556|       |    /* Compose the output array. */
 1557|       |    /* opening square bracket */
 1558|  1.68k|    output_pointer = ensure(output_buffer, 1);
 1559|  1.68k|    if (output_pointer == NULL)
 1560|      0|    {
 1561|      0|        return false;
 1562|      0|    }
 1563|       |
 1564|  1.68k|    *output_pointer = '[';
 1565|  1.68k|    output_buffer->offset++;
 1566|  1.68k|    output_buffer->depth++;
 1567|       |
 1568|  6.58k|    while (current_element != NULL)
 1569|  4.90k|    {
 1570|  4.90k|        if (!print_value(current_element, output_buffer))
 1571|      0|        {
 1572|      0|            return false;
 1573|      0|        }
 1574|  4.90k|        update_offset(output_buffer);
 1575|  4.90k|        if (current_element->next)
 1576|  3.30k|        {
 1577|  3.30k|            length = (size_t) (output_buffer->format ? 2 : 1);
 1578|  3.30k|            output_pointer = ensure(output_buffer, length + 1);
 1579|  3.30k|            if (output_pointer == NULL)
 1580|      0|            {
 1581|      0|                return false;
 1582|      0|            }
 1583|  3.30k|            *output_pointer++ = ',';
 1584|  3.30k|            if(output_buffer->format)
 1585|  1.96k|            {
 1586|  1.96k|                *output_pointer++ = ' ';
 1587|  1.96k|            }
 1588|  3.30k|            *output_pointer = '\0';
 1589|  3.30k|            output_buffer->offset += length;
 1590|  3.30k|        }
 1591|  4.90k|        current_element = current_element->next;
 1592|  4.90k|    }
 1593|       |
 1594|  1.68k|    output_pointer = ensure(output_buffer, 2);
 1595|  1.68k|    if (output_pointer == NULL)
 1596|      0|    {
 1597|      0|        return false;
 1598|      0|    }
 1599|  1.68k|    *output_pointer++ = ']';
 1600|  1.68k|    *output_pointer = '\0';
 1601|  1.68k|    output_buffer->depth--;
 1602|       |
 1603|  1.68k|    return true;
 1604|  1.68k|}
 1605|       |
 1606|       |/* Build an object from the text. */
 1607|       |static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
 1608|  3.61k|{
 1609|  3.61k|    cJSON *head = NULL; /* linked list head */
 1610|  3.61k|    cJSON *current_item = NULL;
 1611|       |
 1612|  3.61k|    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
 1613|      0|    {
 1614|      0|        return false; /* to deeply nested */
 1615|      0|    }
 1616|  3.61k|    input_buffer->depth++;
 1617|       |
 1618|  3.61k|    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
 1619|      0|    {
 1620|      0|        goto fail; /* not an object */
 1621|      0|    }
 1622|       |
 1623|  3.61k|    input_buffer->offset++;
 1624|  3.61k|    buffer_skip_whitespace(input_buffer);
 1625|  3.61k|    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
 1626|     71|    {
 1627|     71|        goto success; /* empty object */
 1628|     71|    }
 1629|       |
 1630|       |    /* check if we skipped to the end of the buffer */
 1631|  3.54k|    if (cannot_access_at_index(input_buffer, 0))
 1632|      0|    {
 1633|      0|        input_buffer->offset--;
 1634|      0|        goto fail;
 1635|      0|    }
 1636|       |
 1637|       |    /* step back to character in front of the first element */
 1638|  3.54k|    input_buffer->offset--;
 1639|       |    /* loop through the comma separated array elements */
 1640|  3.54k|    do
 1641|  15.4k|    {
 1642|       |        /* allocate next item */
 1643|  15.4k|        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
 1644|  15.4k|        if (new_item == NULL)
 1645|      0|        {
 1646|      0|            goto fail; /* allocation failure */
 1647|      0|        }
 1648|       |
 1649|       |        /* attach next item to list */
 1650|  15.4k|        if (head == NULL)
 1651|  3.54k|        {
 1652|       |            /* start the linked list */
 1653|  3.54k|            current_item = head = new_item;
 1654|  3.54k|        }
 1655|  11.9k|        else
 1656|  11.9k|        {
 1657|       |            /* add to the end and advance */
 1658|  11.9k|            current_item->next = new_item;
 1659|  11.9k|            new_item->prev = current_item;
 1660|  11.9k|            current_item = new_item;
 1661|  11.9k|        }
 1662|       |
 1663|  15.4k|        if (cannot_access_at_index(input_buffer, 1))
 1664|      0|        {
 1665|      0|            goto fail; /* nothing comes after the comma */
 1666|      0|        }
 1667|       |
 1668|       |        /* parse the name of the child */
 1669|  15.4k|        input_buffer->offset++;
 1670|  15.4k|        buffer_skip_whitespace(input_buffer);
 1671|  15.4k|        if (!parse_string(current_item, input_buffer))
 1672|     96|        {
 1673|     96|            goto fail; /* failed to parse name */
 1674|     96|        }
 1675|  15.3k|        buffer_skip_whitespace(input_buffer);
 1676|       |
 1677|       |        /* swap valuestring and string, because we parsed the name */
 1678|  15.3k|        current_item->string = current_item->valuestring;
 1679|  15.3k|        current_item->valuestring = NULL;
 1680|       |
 1681|  15.3k|        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
 1682|    142|        {
 1683|    142|            goto fail; /* invalid object */
 1684|    142|        }
 1685|       |
 1686|       |        /* parse the value */
 1687|  15.2k|        input_buffer->offset++;
 1688|  15.2k|        buffer_skip_whitespace(input_buffer);
 1689|  15.2k|        if (!parse_value(current_item, input_buffer))
 1690|    387|        {
 1691|    387|            goto fail; /* failed to parse value */
 1692|    387|        }
 1693|  14.8k|        buffer_skip_whitespace(input_buffer);
 1694|  14.8k|    }
 1695|  14.8k|    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
 1696|       |
 1697|  2.92k|    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
 1698|    154|    {
 1699|    154|        goto fail; /* expected end of object */
 1700|    154|    }
 1701|       |
 1702|  2.83k|success:
 1703|  2.83k|    input_buffer->depth--;
 1704|       |
 1705|  2.83k|    if (head != NULL) {
 1706|  2.76k|        head->prev = current_item;
 1707|  2.76k|    }
 1708|       |
 1709|  2.83k|    item->type = cJSON_Object;
 1710|  2.83k|    item->child = head;
 1711|       |
 1712|  2.83k|    input_buffer->offset++;
 1713|  2.83k|    return true;
 1714|       |
 1715|    779|fail:
 1716|    779|    if (head != NULL)
 1717|    779|    {
 1718|    779|        cJSON_Delete(head);
 1719|    779|    }
 1720|       |
 1721|    779|    return false;
 1722|  2.92k|}
 1723|       |
 1724|       |/* Render an object to text. */
 1725|       |static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
 1726|  2.51k|{
 1727|  2.51k|    unsigned char *output_pointer = NULL;
 1728|  2.51k|    size_t length = 0;
 1729|  2.51k|    cJSON *current_item = item->child;
 1730|       |
 1731|  2.51k|    if (output_buffer == NULL)
 1732|      0|    {
 1733|      0|        return false;
 1734|      0|    }
 1735|       |
 1736|       |    /* Compose the output: */
 1737|  2.51k|    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
 1738|  2.51k|    output_pointer = ensure(output_buffer, length + 1);
 1739|  2.51k|    if (output_pointer == NULL)
 1740|      0|    {
 1741|      0|        return false;
 1742|      0|    }
 1743|       |
 1744|  2.51k|    *output_pointer++ = '{';
 1745|  2.51k|    output_buffer->depth++;
 1746|  2.51k|    if (output_buffer->format)
 1747|  1.97k|    {
 1748|  1.97k|        *output_pointer++ = '\n';
 1749|  1.97k|    }
 1750|  2.51k|    output_buffer->offset += length;
 1751|       |
 1752|  14.0k|    while (current_item)
 1753|  11.4k|    {
 1754|  11.4k|        if (output_buffer->format)
 1755|  9.65k|        {
 1756|  9.65k|            size_t i;
 1757|  9.65k|            output_pointer = ensure(output_buffer, output_buffer->depth);
 1758|  9.65k|            if (output_pointer == NULL)
 1759|      0|            {
 1760|      0|                return false;
 1761|      0|            }
 1762|  45.8k|            for (i = 0; i < output_buffer->depth; i++)
 1763|  36.2k|            {
 1764|  36.2k|                *output_pointer++ = '\t';
 1765|  36.2k|            }
 1766|  9.65k|            output_buffer->offset += output_buffer->depth;
 1767|  9.65k|        }
 1768|       |
 1769|       |        /* print key */
 1770|  11.4k|        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
 1771|      0|        {
 1772|      0|            return false;
 1773|      0|        }
 1774|  11.4k|        update_offset(output_buffer);
 1775|       |
 1776|  11.4k|        length = (size_t) (output_buffer->format ? 2 : 1);
 1777|  11.4k|        output_pointer = ensure(output_buffer, length);
 1778|  11.4k|        if (output_pointer == NULL)
 1779|      0|        {
 1780|      0|            return false;
 1781|      0|        }
 1782|  11.4k|        *output_pointer++ = ':';
 1783|  11.4k|        if (output_buffer->format)
 1784|  9.65k|        {
 1785|  9.65k|            *output_pointer++ = '\t';
 1786|  9.65k|        }
 1787|  11.4k|        output_buffer->offset += length;
 1788|       |
 1789|       |        /* print value */
 1790|  11.4k|        if (!print_value(current_item, output_buffer))
 1791|      0|        {
 1792|      0|            return false;
 1793|      0|        }
 1794|  11.4k|        update_offset(output_buffer);
 1795|       |
 1796|       |        /* print comma if not last */
 1797|  11.4k|        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
 1798|  11.4k|        output_pointer = ensure(output_buffer, length + 1);
 1799|  11.4k|        if (output_pointer == NULL)
 1800|      0|        {
 1801|      0|            return false;
 1802|      0|        }
 1803|  11.4k|        if (current_item->next)
 1804|  9.02k|        {
 1805|  9.02k|            *output_pointer++ = ',';
 1806|  9.02k|        }
 1807|       |
 1808|  11.4k|        if (output_buffer->format)
 1809|  9.65k|        {
 1810|  9.65k|            *output_pointer++ = '\n';
 1811|  9.65k|        }
 1812|  11.4k|        *output_pointer = '\0';
 1813|  11.4k|        output_buffer->offset += length;
 1814|       |
 1815|  11.4k|        current_item = current_item->next;
 1816|  11.4k|    }
 1817|       |
 1818|  2.51k|    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
 1819|  2.51k|    if (output_pointer == NULL)
 1820|      0|    {
 1821|      0|        return false;
 1822|      0|    }
 1823|  2.51k|    if (output_buffer->format)
 1824|  1.97k|    {
 1825|  1.97k|        size_t i;
 1826|  6.60k|        for (i = 0; i < (output_buffer->depth - 1); i++)
 1827|  4.63k|        {
 1828|  4.63k|            *output_pointer++ = '\t';
 1829|  4.63k|        }
 1830|  1.97k|    }
 1831|  2.51k|    *output_pointer++ = '}';
 1832|  2.51k|    *output_pointer = '\0';
 1833|  2.51k|    output_buffer->depth--;
 1834|       |
 1835|  2.51k|    return true;
 1836|  2.51k|}
 1837|       |
 1838|       |/* Get Array size/item / object item. */
 1839|       |CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
 1840|      0|{
 1841|      0|    cJSON *child = NULL;
 1842|      0|    size_t size = 0;
 1843|       |
 1844|      0|    if (array == NULL)
 1845|      0|    {
 1846|      0|        return 0;
 1847|      0|    }
 1848|       |
 1849|      0|    child = array->child;
 1850|       |
 1851|      0|    while(child != NULL)
 1852|      0|    {
 1853|      0|        size++;
 1854|      0|        child = child->next;
 1855|      0|    }
 1856|       |
 1857|       |    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
 1858|       |
 1859|      0|    return (int)size;
 1860|      0|}
 1861|       |
 1862|       |static cJSON* get_array_item(const cJSON *array, size_t index)
 1863|      0|{
 1864|      0|    cJSON *current_child = NULL;
 1865|       |
 1866|      0|    if (array == NULL)
 1867|      0|    {
 1868|      0|        return NULL;
 1869|      0|    }
 1870|       |
 1871|      0|    current_child = array->child;
 1872|      0|    while ((current_child != NULL) && (index > 0))
 1873|      0|    {
 1874|      0|        index--;
 1875|      0|        current_child = current_child->next;
 1876|      0|    }
 1877|       |
 1878|      0|    return current_child;
 1879|      0|}
 1880|       |
 1881|       |CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
 1882|      0|{
 1883|      0|    if (index < 0)
 1884|      0|    {
 1885|      0|        return NULL;
 1886|      0|    }
 1887|       |
 1888|      0|    return get_array_item(array, (size_t)index);
 1889|      0|}
 1890|       |
 1891|       |static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
 1892|      0|{
 1893|      0|    cJSON *current_element = NULL;
 1894|       |
 1895|      0|    if ((object == NULL) || (name == NULL))
 1896|      0|    {
 1897|      0|        return NULL;
 1898|      0|    }
 1899|       |
 1900|      0|    current_element = object->child;
 1901|      0|    if (case_sensitive)
 1902|      0|    {
 1903|      0|        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
 1904|      0|        {
 1905|      0|            current_element = current_element->next;
 1906|      0|        }
 1907|      0|    }
 1908|      0|    else
 1909|      0|    {
 1910|      0|        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
 1911|      0|        {
 1912|      0|            current_element = current_element->next;
 1913|      0|        }
 1914|      0|    }
 1915|       |
 1916|      0|    if ((current_element == NULL) || (current_element->string == NULL)) {
 1917|      0|        return NULL;
 1918|      0|    }
 1919|       |
 1920|      0|    return current_element;
 1921|      0|}
 1922|       |
 1923|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
 1924|      0|{
 1925|      0|    return get_object_item(object, string, false);
 1926|      0|}
 1927|       |
 1928|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
 1929|      0|{
 1930|      0|    return get_object_item(object, string, true);
 1931|      0|}
 1932|       |
 1933|       |CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
 1934|      0|{
 1935|      0|    return cJSON_GetObjectItem(object, string) ? 1 : 0;
 1936|      0|}
 1937|       |
 1938|       |/* Utility for array list handling. */
 1939|       |static void suffix_object(cJSON *prev, cJSON *item)
 1940|      0|{
 1941|      0|    prev->next = item;
 1942|      0|    item->prev = prev;
 1943|      0|}
 1944|       |
 1945|       |/* Utility for handling references. */
 1946|       |static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
 1947|      0|{
 1948|      0|    cJSON *reference = NULL;
 1949|      0|    if (item == NULL)
 1950|      0|    {
 1951|      0|        return NULL;
 1952|      0|    }
 1953|       |
 1954|      0|    reference = cJSON_New_Item(hooks);
 1955|      0|    if (reference == NULL)
 1956|      0|    {
 1957|      0|        return NULL;
 1958|      0|    }
 1959|       |
 1960|      0|    memcpy(reference, item, sizeof(cJSON));
 1961|      0|    reference->string = NULL;
 1962|      0|    reference->type |= cJSON_IsReference;
 1963|      0|    reference->next = reference->prev = NULL;
 1964|      0|    return reference;
 1965|      0|}
 1966|       |
 1967|       |static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
 1968|      0|{
 1969|      0|    cJSON *child = NULL;
 1970|       |
 1971|      0|    if ((item == NULL) || (array == NULL) || (array == item))
 1972|      0|    {
 1973|      0|        return false;
 1974|      0|    }
 1975|       |
 1976|      0|    child = array->child;
 1977|       |    /*
 1978|       |     * To find the last item in array quickly, we use prev in array
 1979|       |     */
 1980|      0|    if (child == NULL)
 1981|      0|    {
 1982|       |        /* list is empty, start new one */
 1983|      0|        array->child = item;
 1984|      0|        item->prev = item;
 1985|      0|        item->next = NULL;
 1986|      0|    }
 1987|      0|    else
 1988|      0|    {
 1989|       |        /* append to the end */
 1990|      0|        if (child->prev)
 1991|      0|        {
 1992|      0|            suffix_object(child->prev, item);
 1993|      0|            array->child->prev = item;
 1994|      0|        }
 1995|      0|    }
 1996|       |
 1997|      0|    return true;
 1998|      0|}
 1999|       |
 2000|       |/* Add item to array/object. */
 2001|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)
 2002|      0|{
 2003|      0|    return add_item_to_array(array, item);
 2004|      0|}
 2005|       |
 2006|       |#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
 2007|       |    #pragma GCC diagnostic push
 2008|       |#endif
 2009|       |#ifdef __GNUC__
 2010|       |#pragma GCC diagnostic ignored "-Wcast-qual"
 2011|       |#endif
 2012|       |/* helper function to cast away const */
 2013|       |static void* cast_away_const(const void* string)
 2014|      0|{
 2015|      0|    return (void*)string;
 2016|      0|}
 2017|       |#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
 2018|       |    #pragma GCC diagnostic pop
 2019|       |#endif
 2020|       |
 2021|       |
 2022|       |static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
 2023|      0|{
 2024|      0|    char *new_key = NULL;
 2025|      0|    int new_type = cJSON_Invalid;
 2026|       |
 2027|      0|    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))
 2028|      0|    {
 2029|      0|        return false;
 2030|      0|    }
 2031|       |
 2032|      0|    if (constant_key)
 2033|      0|    {
 2034|      0|        new_key = (char*)cast_away_const(string);
 2035|      0|        new_type = item->type | cJSON_StringIsConst;
 2036|      0|    }
 2037|      0|    else
 2038|      0|    {
 2039|      0|        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
 2040|      0|        if (new_key == NULL)
 2041|      0|        {
 2042|      0|            return false;
 2043|      0|        }
 2044|       |
 2045|      0|        new_type = item->type & ~cJSON_StringIsConst;
 2046|      0|    }
 2047|       |
 2048|      0|    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
 2049|      0|    {
 2050|      0|        hooks->deallocate(item->string);
 2051|      0|    }
 2052|       |
 2053|      0|    item->string = new_key;
 2054|      0|    item->type = new_type;
 2055|       |
 2056|      0|    return add_item_to_array(object, item);
 2057|      0|}
 2058|       |
 2059|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
 2060|      0|{
 2061|      0|    return add_item_to_object(object, string, item, &global_hooks, false);
 2062|      0|}
 2063|       |
 2064|       |/* Add an item to an object with constant string as key */
 2065|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
 2066|      0|{
 2067|      0|    return add_item_to_object(object, string, item, &global_hooks, true);
 2068|      0|}
 2069|       |
 2070|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
 2071|      0|{
 2072|      0|    if (array == NULL)
 2073|      0|    {
 2074|      0|        return false;
 2075|      0|    }
 2076|       |
 2077|      0|    return add_item_to_array(array, create_reference(item, &global_hooks));
 2078|      0|}
 2079|       |
 2080|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
 2081|      0|{
 2082|      0|    if ((object == NULL) || (string == NULL))
 2083|      0|    {
 2084|      0|        return false;
 2085|      0|    }
 2086|       |
 2087|      0|    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
 2088|      0|}
 2089|       |
 2090|       |CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
 2091|      0|{
 2092|      0|    cJSON *null = cJSON_CreateNull();
 2093|      0|    if (add_item_to_object(object, name, null, &global_hooks, false))
 2094|      0|    {
 2095|      0|        return null;
 2096|      0|    }
 2097|       |
 2098|      0|    cJSON_Delete(null);
 2099|      0|    return NULL;
 2100|      0|}
 2101|       |
 2102|       |CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
 2103|      0|{
 2104|      0|    cJSON *true_item = cJSON_CreateTrue();
 2105|      0|    if (add_item_to_object(object, name, true_item, &global_hooks, false))
 2106|      0|    {
 2107|      0|        return true_item;
 2108|      0|    }
 2109|       |
 2110|      0|    cJSON_Delete(true_item);
 2111|      0|    return NULL;
 2112|      0|}
 2113|       |
 2114|       |CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
 2115|      0|{
 2116|      0|    cJSON *false_item = cJSON_CreateFalse();
 2117|      0|    if (add_item_to_object(object, name, false_item, &global_hooks, false))
 2118|      0|    {
 2119|      0|        return false_item;
 2120|      0|    }
 2121|       |
 2122|      0|    cJSON_Delete(false_item);
 2123|      0|    return NULL;
 2124|      0|}
 2125|       |
 2126|       |CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
 2127|      0|{
 2128|      0|    cJSON *bool_item = cJSON_CreateBool(boolean);
 2129|      0|    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
 2130|      0|    {
 2131|      0|        return bool_item;
 2132|      0|    }
 2133|       |
 2134|      0|    cJSON_Delete(bool_item);
 2135|      0|    return NULL;
 2136|      0|}
 2137|       |
 2138|       |CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
 2139|      0|{
 2140|      0|    cJSON *number_item = cJSON_CreateNumber(number);
 2141|      0|    if (add_item_to_object(object, name, number_item, &global_hooks, false))
 2142|      0|    {
 2143|      0|        return number_item;
 2144|      0|    }
 2145|       |
 2146|      0|    cJSON_Delete(number_item);
 2147|      0|    return NULL;
 2148|      0|}
 2149|       |
 2150|       |CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
 2151|      0|{
 2152|      0|    cJSON *string_item = cJSON_CreateString(string);
 2153|      0|    if (add_item_to_object(object, name, string_item, &global_hooks, false))
 2154|      0|    {
 2155|      0|        return string_item;
 2156|      0|    }
 2157|       |
 2158|      0|    cJSON_Delete(string_item);
 2159|      0|    return NULL;
 2160|      0|}
 2161|       |
 2162|       |CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
 2163|      0|{
 2164|      0|    cJSON *raw_item = cJSON_CreateRaw(raw);
 2165|      0|    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
 2166|      0|    {
 2167|      0|        return raw_item;
 2168|      0|    }
 2169|       |
 2170|      0|    cJSON_Delete(raw_item);
 2171|      0|    return NULL;
 2172|      0|}
 2173|       |
 2174|       |CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
 2175|      0|{
 2176|      0|    cJSON *object_item = cJSON_CreateObject();
 2177|      0|    if (add_item_to_object(object, name, object_item, &global_hooks, false))
 2178|      0|    {
 2179|      0|        return object_item;
 2180|      0|    }
 2181|       |
 2182|      0|    cJSON_Delete(object_item);
 2183|      0|    return NULL;
 2184|      0|}
 2185|       |
 2186|       |CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
 2187|      0|{
 2188|      0|    cJSON *array = cJSON_CreateArray();
 2189|      0|    if (add_item_to_object(object, name, array, &global_hooks, false))
 2190|      0|    {
 2191|      0|        return array;
 2192|      0|    }
 2193|       |
 2194|      0|    cJSON_Delete(array);
 2195|      0|    return NULL;
 2196|      0|}
 2197|       |
 2198|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
 2199|      0|{
 2200|      0|    if ((parent == NULL) || (item == NULL))
 2201|      0|    {
 2202|      0|        return NULL;
 2203|      0|    }
 2204|       |
 2205|      0|    if (item != parent->child)
 2206|      0|    {
 2207|       |        /* not the first element */
 2208|      0|        item->prev->next = item->next;
 2209|      0|    }
 2210|      0|    if (item->next != NULL)
 2211|      0|    {
 2212|       |        /* not the last element */
 2213|      0|        item->next->prev = item->prev;
 2214|      0|    }
 2215|       |
 2216|      0|    if (item == parent->child)
 2217|      0|    {
 2218|       |        /* first element */
 2219|      0|        parent->child = item->next;
 2220|      0|    }
 2221|      0|    else if (item->next == NULL)
 2222|      0|    {
 2223|       |        /* last element */
 2224|      0|        parent->child->prev = item->prev;
 2225|      0|    }
 2226|       |
 2227|       |    /* make sure the detached item doesn't point anywhere anymore */
 2228|      0|    item->prev = NULL;
 2229|      0|    item->next = NULL;
 2230|       |
 2231|      0|    return item;
 2232|      0|}
 2233|       |
 2234|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
 2235|      0|{
 2236|      0|    if (which < 0)
 2237|      0|    {
 2238|      0|        return NULL;
 2239|      0|    }
 2240|       |
 2241|      0|    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
 2242|      0|}
 2243|       |
 2244|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
 2245|      0|{
 2246|      0|    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
 2247|      0|}
 2248|       |
 2249|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
 2250|      0|{
 2251|      0|    cJSON *to_detach = cJSON_GetObjectItem(object, string);
 2252|       |
 2253|      0|    return cJSON_DetachItemViaPointer(object, to_detach);
 2254|      0|}
 2255|       |
 2256|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
 2257|      0|{
 2258|      0|    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
 2259|       |
 2260|      0|    return cJSON_DetachItemViaPointer(object, to_detach);
 2261|      0|}
 2262|       |
 2263|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
 2264|      0|{
 2265|      0|    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
 2266|      0|}
 2267|       |
 2268|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
 2269|      0|{
 2270|      0|    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
 2271|      0|}
 2272|       |
 2273|       |/* Replace array/object items with new ones. */
 2274|       |CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
 2275|      0|{
 2276|      0|    cJSON *after_inserted = NULL;
 2277|       |
 2278|      0|    if (which < 0 || newitem == NULL)
 2279|      0|    {
 2280|      0|        return false;
 2281|      0|    }
 2282|       |
 2283|      0|    after_inserted = get_array_item(array, (size_t)which);
 2284|      0|    if (after_inserted == NULL)
 2285|      0|    {
 2286|      0|        return add_item_to_array(array, newitem);
 2287|      0|    }
 2288|       |
 2289|      0|    if (after_inserted != array->child && after_inserted->prev == NULL) {
 2290|       |        /* return false if after_inserted is a corrupted array item */
 2291|      0|        return false;
 2292|      0|    }
 2293|       |
 2294|      0|    newitem->next = after_inserted;
 2295|      0|    newitem->prev = after_inserted->prev;
 2296|      0|    after_inserted->prev = newitem;
 2297|      0|    if (after_inserted == array->child)
 2298|      0|    {
 2299|      0|        array->child = newitem;
 2300|      0|    }
 2301|      0|    else
 2302|      0|    {
 2303|      0|        newitem->prev->next = newitem;
 2304|      0|    }
 2305|      0|    return true;
 2306|      0|}
 2307|       |
 2308|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
 2309|      0|{
 2310|      0|    if ((parent == NULL) || (parent->child == NULL) || (replacement == NULL) || (item == NULL))
 2311|      0|    {
 2312|      0|        return false;
 2313|      0|    }
 2314|       |
 2315|      0|    if (replacement == item)
 2316|      0|    {
 2317|      0|        return true;
 2318|      0|    }
 2319|       |
 2320|      0|    replacement->next = item->next;
 2321|      0|    replacement->prev = item->prev;
 2322|       |
 2323|      0|    if (replacement->next != NULL)
 2324|      0|    {
 2325|      0|        replacement->next->prev = replacement;
 2326|      0|    }
 2327|      0|    if (parent->child == item)
 2328|      0|    {
 2329|      0|        if (parent->child->prev == parent->child)
 2330|      0|        {
 2331|      0|            replacement->prev = replacement;
 2332|      0|        }
 2333|      0|        parent->child = replacement;
 2334|      0|    }
 2335|      0|    else
 2336|      0|    {   /*
 2337|       |         * To find the last item in array quickly, we use prev in array.
 2338|       |         * We can't modify the last item's next pointer where this item was the parent's child
 2339|       |         */
 2340|      0|        if (replacement->prev != NULL)
 2341|      0|        {
 2342|      0|            replacement->prev->next = replacement;
 2343|      0|        }
 2344|      0|        if (replacement->next == NULL)
 2345|      0|        {
 2346|      0|            parent->child->prev = replacement;
 2347|      0|        }
 2348|      0|    }
 2349|       |
 2350|      0|    item->next = NULL;
 2351|      0|    item->prev = NULL;
 2352|      0|    cJSON_Delete(item);
 2353|       |
 2354|      0|    return true;
 2355|      0|}
 2356|       |
 2357|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
 2358|      0|{
 2359|      0|    if (which < 0)
 2360|      0|    {
 2361|      0|        return false;
 2362|      0|    }
 2363|       |
 2364|      0|    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
 2365|      0|}
 2366|       |
 2367|       |static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
 2368|      0|{
 2369|      0|    if ((replacement == NULL) || (string == NULL))
 2370|      0|    {
 2371|      0|        return false;
 2372|      0|    }
 2373|       |
 2374|       |    /* replace the name in the replacement */
 2375|      0|    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
 2376|      0|    {
 2377|      0|        cJSON_free(replacement->string);
 2378|      0|    }
 2379|      0|    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
 2380|      0|    if (replacement->string == NULL)
 2381|      0|    {
 2382|      0|        return false;
 2383|      0|    }
 2384|       |
 2385|      0|    replacement->type &= ~cJSON_StringIsConst;
 2386|       |
 2387|      0|    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
 2388|      0|}
 2389|       |
 2390|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
 2391|      0|{
 2392|      0|    return replace_item_in_object(object, string, newitem, false);
 2393|      0|}
 2394|       |
 2395|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
 2396|      0|{
 2397|      0|    return replace_item_in_object(object, string, newitem, true);
 2398|      0|}
 2399|       |
 2400|       |/* Create basic types: */
 2401|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
 2402|      0|{
 2403|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2404|      0|    if(item)
 2405|      0|    {
 2406|      0|        item->type = cJSON_NULL;
 2407|      0|    }
 2408|       |
 2409|      0|    return item;
 2410|      0|}
 2411|       |
 2412|       |CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
 2413|      0|{
 2414|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2415|      0|    if(item)
 2416|      0|    {
 2417|      0|        item->type = cJSON_True;
 2418|      0|    }
 2419|       |
 2420|      0|    return item;
 2421|      0|}
 2422|       |
 2423|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
 2424|      0|{
 2425|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2426|      0|    if(item)
 2427|      0|    {
 2428|      0|        item->type = cJSON_False;
 2429|      0|    }
 2430|       |
 2431|      0|    return item;
 2432|      0|}
 2433|       |
 2434|       |CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
 2435|      0|{
 2436|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2437|      0|    if(item)
 2438|      0|    {
 2439|      0|        item->type = boolean ? cJSON_True : cJSON_False;
 2440|      0|    }
 2441|       |
 2442|      0|    return item;
 2443|      0|}
 2444|       |
 2445|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
 2446|      0|{
 2447|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2448|      0|    if(item)
 2449|      0|    {
 2450|      0|        item->type = cJSON_Number;
 2451|      0|        item->valuedouble = num;
 2452|       |
 2453|       |        /* use saturation in case of overflow */
 2454|      0|        if (num >= INT_MAX)
 2455|      0|        {
 2456|      0|            item->valueint = INT_MAX;
 2457|      0|        }
 2458|      0|        else if (num <= (double)INT_MIN)
 2459|      0|        {
 2460|      0|            item->valueint = INT_MIN;
 2461|      0|        }
 2462|      0|        else
 2463|      0|        {
 2464|      0|            item->valueint = (int)num;
 2465|      0|        }
 2466|      0|    }
 2467|       |
 2468|      0|    return item;
 2469|      0|}
 2470|       |
 2471|       |CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
 2472|      0|{
 2473|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2474|      0|    if(item)
 2475|      0|    {
 2476|      0|        item->type = cJSON_String;
 2477|      0|        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
 2478|      0|        if(!item->valuestring)
 2479|      0|        {
 2480|      0|            cJSON_Delete(item);
 2481|      0|            return NULL;
 2482|      0|        }
 2483|      0|    }
 2484|       |
 2485|      0|    return item;
 2486|      0|}
 2487|       |
 2488|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
 2489|      0|{
 2490|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2491|      0|    if (item != NULL)
 2492|      0|    {
 2493|      0|        item->type = cJSON_String | cJSON_IsReference;
 2494|      0|        item->valuestring = (char*)cast_away_const(string);
 2495|      0|    }
 2496|       |
 2497|      0|    return item;
 2498|      0|}
 2499|       |
 2500|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
 2501|      0|{
 2502|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2503|      0|    if (item != NULL) {
 2504|      0|        item->type = cJSON_Object | cJSON_IsReference;
 2505|      0|        item->child = (cJSON*)cast_away_const(child);
 2506|      0|    }
 2507|       |
 2508|      0|    return item;
 2509|      0|}
 2510|       |
 2511|      0|CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
 2512|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2513|      0|    if (item != NULL) {
 2514|      0|        item->type = cJSON_Array | cJSON_IsReference;
 2515|      0|        item->child = (cJSON*)cast_away_const(child);
 2516|      0|    }
 2517|       |
 2518|      0|    return item;
 2519|      0|}
 2520|       |
 2521|       |CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
 2522|      0|{
 2523|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2524|      0|    if(item)
 2525|      0|    {
 2526|      0|        item->type = cJSON_Raw;
 2527|      0|        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
 2528|      0|        if(!item->valuestring)
 2529|      0|        {
 2530|      0|            cJSON_Delete(item);
 2531|      0|            return NULL;
 2532|      0|        }
 2533|      0|    }
 2534|       |
 2535|      0|    return item;
 2536|      0|}
 2537|       |
 2538|       |CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
 2539|      0|{
 2540|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2541|      0|    if(item)
 2542|      0|    {
 2543|      0|        item->type=cJSON_Array;
 2544|      0|    }
 2545|       |
 2546|      0|    return item;
 2547|      0|}
 2548|       |
 2549|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
 2550|      0|{
 2551|      0|    cJSON *item = cJSON_New_Item(&global_hooks);
 2552|      0|    if (item)
 2553|      0|    {
 2554|      0|        item->type = cJSON_Object;
 2555|      0|    }
 2556|       |
 2557|      0|    return item;
 2558|      0|}
 2559|       |
 2560|       |/* Create Arrays: */
 2561|       |CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
 2562|      0|{
 2563|      0|    size_t i = 0;
 2564|      0|    cJSON *n = NULL;
 2565|      0|    cJSON *p = NULL;
 2566|      0|    cJSON *a = NULL;
 2567|       |
 2568|      0|    if ((count < 0) || (numbers == NULL))
 2569|      0|    {
 2570|      0|        return NULL;
 2571|      0|    }
 2572|       |
 2573|      0|    a = cJSON_CreateArray();
 2574|       |
 2575|      0|    for(i = 0; a && (i < (size_t)count); i++)
 2576|      0|    {
 2577|      0|        n = cJSON_CreateNumber(numbers[i]);
 2578|      0|        if (!n)
 2579|      0|        {
 2580|      0|            cJSON_Delete(a);
 2581|      0|            return NULL;
 2582|      0|        }
 2583|      0|        if(!i)
 2584|      0|        {
 2585|      0|            a->child = n;
 2586|      0|        }
 2587|      0|        else
 2588|      0|        {
 2589|      0|            suffix_object(p, n);
 2590|      0|        }
 2591|      0|        p = n;
 2592|      0|    }
 2593|       |
 2594|      0|    if (a && a->child) {
 2595|      0|        a->child->prev = n;
 2596|      0|    }
 2597|       |
 2598|      0|    return a;
 2599|      0|}
 2600|       |
 2601|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
 2602|      0|{
 2603|      0|    size_t i = 0;
 2604|      0|    cJSON *n = NULL;
 2605|      0|    cJSON *p = NULL;
 2606|      0|    cJSON *a = NULL;
 2607|       |
 2608|      0|    if ((count < 0) || (numbers == NULL))
 2609|      0|    {
 2610|      0|        return NULL;
 2611|      0|    }
 2612|       |
 2613|      0|    a = cJSON_CreateArray();
 2614|       |
 2615|      0|    for(i = 0; a && (i < (size_t)count); i++)
 2616|      0|    {
 2617|      0|        n = cJSON_CreateNumber((double)numbers[i]);
 2618|      0|        if(!n)
 2619|      0|        {
 2620|      0|            cJSON_Delete(a);
 2621|      0|            return NULL;
 2622|      0|        }
 2623|      0|        if(!i)
 2624|      0|        {
 2625|      0|            a->child = n;
 2626|      0|        }
 2627|      0|        else
 2628|      0|        {
 2629|      0|            suffix_object(p, n);
 2630|      0|        }
 2631|      0|        p = n;
 2632|      0|    }
 2633|       |
 2634|      0|    if (a && a->child) {
 2635|      0|        a->child->prev = n;
 2636|      0|    }
 2637|       |
 2638|      0|    return a;
 2639|      0|}
 2640|       |
 2641|       |CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
 2642|      0|{
 2643|      0|    size_t i = 0;
 2644|      0|    cJSON *n = NULL;
 2645|      0|    cJSON *p = NULL;
 2646|      0|    cJSON *a = NULL;
 2647|       |
 2648|      0|    if ((count < 0) || (numbers == NULL))
 2649|      0|    {
 2650|      0|        return NULL;
 2651|      0|    }
 2652|       |
 2653|      0|    a = cJSON_CreateArray();
 2654|       |
 2655|      0|    for(i = 0; a && (i < (size_t)count); i++)
 2656|      0|    {
 2657|      0|        n = cJSON_CreateNumber(numbers[i]);
 2658|      0|        if(!n)
 2659|      0|        {
 2660|      0|            cJSON_Delete(a);
 2661|      0|            return NULL;
 2662|      0|        }
 2663|      0|        if(!i)
 2664|      0|        {
 2665|      0|            a->child = n;
 2666|      0|        }
 2667|      0|        else
 2668|      0|        {
 2669|      0|            suffix_object(p, n);
 2670|      0|        }
 2671|      0|        p = n;
 2672|      0|    }
 2673|       |
 2674|      0|    if (a && a->child) {
 2675|      0|        a->child->prev = n;
 2676|      0|    }
 2677|       |
 2678|      0|    return a;
 2679|      0|}
 2680|       |
 2681|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
 2682|      0|{
 2683|      0|    size_t i = 0;
 2684|      0|    cJSON *n = NULL;
 2685|      0|    cJSON *p = NULL;
 2686|      0|    cJSON *a = NULL;
 2687|       |
 2688|      0|    if ((count < 0) || (strings == NULL))
 2689|      0|    {
 2690|      0|        return NULL;
 2691|      0|    }
 2692|       |
 2693|      0|    a = cJSON_CreateArray();
 2694|       |
 2695|      0|    for (i = 0; a && (i < (size_t)count); i++)
 2696|      0|    {
 2697|      0|        n = cJSON_CreateString(strings[i]);
 2698|      0|        if(!n)
 2699|      0|        {
 2700|      0|            cJSON_Delete(a);
 2701|      0|            return NULL;
 2702|      0|        }
 2703|      0|        if(!i)
 2704|      0|        {
 2705|      0|            a->child = n;
 2706|      0|        }
 2707|      0|        else
 2708|      0|        {
 2709|      0|            suffix_object(p,n);
 2710|      0|        }
 2711|      0|        p = n;
 2712|      0|    }
 2713|       |
 2714|      0|    if (a && a->child) {
 2715|      0|        a->child->prev = n;
 2716|      0|    }
 2717|       |
 2718|      0|    return a;
 2719|      0|}
 2720|       |
 2721|       |/* Duplication */
 2722|       |CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
 2723|      0|{
 2724|      0|    cJSON *newitem = NULL;
 2725|      0|    cJSON *child = NULL;
 2726|      0|    cJSON *next = NULL;
 2727|      0|    cJSON *newchild = NULL;
 2728|       |
 2729|       |    /* Bail on bad ptr */
 2730|      0|    if (!item)
 2731|      0|    {
 2732|      0|        goto fail;
 2733|      0|    }
 2734|       |    /* Create new item */
 2735|      0|    newitem = cJSON_New_Item(&global_hooks);
 2736|      0|    if (!newitem)
 2737|      0|    {
 2738|      0|        goto fail;
 2739|      0|    }
 2740|       |    /* Copy over all vars */
 2741|      0|    newitem->type = item->type & (~cJSON_IsReference);
 2742|      0|    newitem->valueint = item->valueint;
 2743|      0|    newitem->valuedouble = item->valuedouble;
 2744|      0|    if (item->valuestring)
 2745|      0|    {
 2746|      0|        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
 2747|      0|        if (!newitem->valuestring)
 2748|      0|        {
 2749|      0|            goto fail;
 2750|      0|        }
 2751|      0|    }
 2752|      0|    if (item->string)
 2753|      0|    {
 2754|      0|        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
 2755|      0|        if (!newitem->string)
 2756|      0|        {
 2757|      0|            goto fail;
 2758|      0|        }
 2759|      0|    }
 2760|       |    /* If non-recursive, then we're done! */
 2761|      0|    if (!recurse)
 2762|      0|    {
 2763|      0|        return newitem;
 2764|      0|    }
 2765|       |    /* Walk the ->next chain for the child. */
 2766|      0|    child = item->child;
 2767|      0|    while (child != NULL)
 2768|      0|    {
 2769|      0|        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
 2770|      0|        if (!newchild)
 2771|      0|        {
 2772|      0|            goto fail;
 2773|      0|        }
 2774|      0|        if (next != NULL)
 2775|      0|        {
 2776|       |            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
 2777|      0|            next->next = newchild;
 2778|      0|            newchild->prev = next;
 2779|      0|            next = newchild;
 2780|      0|        }
 2781|      0|        else
 2782|      0|        {
 2783|       |            /* Set newitem->child and move to it */
 2784|      0|            newitem->child = newchild;
 2785|      0|            next = newchild;
 2786|      0|        }
 2787|      0|        child = child->next;
 2788|      0|    }
 2789|      0|    if (newitem && newitem->child)
 2790|      0|    {
 2791|      0|        newitem->child->prev = newchild;
 2792|      0|    }
 2793|       |
 2794|      0|    return newitem;
 2795|       |
 2796|      0|fail:
 2797|      0|    if (newitem != NULL)
 2798|      0|    {
 2799|      0|        cJSON_Delete(newitem);
 2800|      0|    }
 2801|       |
 2802|      0|    return NULL;
 2803|      0|}
 2804|       |
 2805|       |static void skip_oneline_comment(char **input)
 2806|      0|{
 2807|      0|    *input += static_strlen("//");
 2808|       |
 2809|      0|    for (; (*input)[0] != '\0'; ++(*input))
 2810|      0|    {
 2811|      0|        if ((*input)[0] == '\n') {
 2812|      0|            *input += static_strlen("\n");
 2813|      0|            return;
 2814|      0|        }
 2815|      0|    }
 2816|      0|}
 2817|       |
 2818|       |static void skip_multiline_comment(char **input)
 2819|      0|{
 2820|      0|    *input += static_strlen("/*");
 2821|       |
 2822|      0|    for (; (*input)[0] != '\0'; ++(*input))
 2823|      0|    {
 2824|      0|        if (((*input)[0] == '*') && ((*input)[1] == '/'))
 2825|      0|        {
 2826|      0|            *input += static_strlen("*/");
 2827|      0|            return;
 2828|      0|        }
 2829|      0|    }
 2830|      0|}
 2831|       |
 2832|      0|static void minify_string(char **input, char **output) {
 2833|      0|    (*output)[0] = (*input)[0];
 2834|      0|    *input += static_strlen("\"");
 2835|      0|    *output += static_strlen("\"");
 2836|       |
 2837|       |
 2838|      0|    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
 2839|      0|        (*output)[0] = (*input)[0];
 2840|       |
 2841|      0|        if ((*input)[0] == '\"') {
 2842|      0|            (*output)[0] = '\"';
 2843|      0|            *input += static_strlen("\"");
 2844|      0|            *output += static_strlen("\"");
 2845|      0|            return;
 2846|      0|        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
 2847|      0|            (*output)[1] = (*input)[1];
 2848|      0|            *input += static_strlen("\"");
 2849|      0|            *output += static_strlen("\"");
 2850|      0|        }
 2851|      0|    }
 2852|      0|}
 2853|       |
 2854|       |CJSON_PUBLIC(void) cJSON_Minify(char *json)
 2855|      0|{
 2856|      0|    char *into = json;
 2857|       |
 2858|      0|    if (json == NULL)
 2859|      0|    {
 2860|      0|        return;
 2861|      0|    }
 2862|       |
 2863|      0|    while (json[0] != '\0')
 2864|      0|    {
 2865|      0|        switch (json[0])
 2866|      0|        {
 2867|      0|            case ' ':
 2868|      0|            case '\t':
 2869|      0|            case '\r':
 2870|      0|            case '\n':
 2871|      0|                json++;
 2872|      0|                break;
 2873|       |
 2874|      0|            case '/':
 2875|      0|                if (json[1] == '/')
 2876|      0|                {
 2877|      0|                    skip_oneline_comment(&json);
 2878|      0|                }
 2879|      0|                else if (json[1] == '*')
 2880|      0|                {
 2881|      0|                    skip_multiline_comment(&json);
 2882|      0|                } else {
 2883|      0|                    json++;
 2884|      0|                }
 2885|      0|                break;
 2886|       |
 2887|      0|            case '\"':
 2888|      0|                minify_string(&json, (char**)&into);
 2889|      0|                break;
 2890|       |
 2891|      0|            default:
 2892|      0|                into[0] = json[0];
 2893|      0|                json++;
 2894|      0|                into++;
 2895|      0|        }
 2896|      0|    }
 2897|       |
 2898|       |    /* and null-terminate. */
 2899|      0|    *into = '\0';
 2900|      0|}
 2901|       |
 2902|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
 2903|      0|{
 2904|      0|    if (item == NULL)
 2905|      0|    {
 2906|      0|        return false;
 2907|      0|    }
 2908|       |
 2909|      0|    return (item->type & 0xFF) == cJSON_Invalid;
 2910|      0|}
 2911|       |
 2912|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
 2913|      0|{
 2914|      0|    if (item == NULL)
 2915|      0|    {
 2916|      0|        return false;
 2917|      0|    }
 2918|       |
 2919|      0|    return (item->type & 0xFF) == cJSON_False;
 2920|      0|}
 2921|       |
 2922|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
 2923|      0|{
 2924|      0|    if (item == NULL)
 2925|      0|    {
 2926|      0|        return false;
 2927|      0|    }
 2928|       |
 2929|      0|    return (item->type & 0xff) == cJSON_True;
 2930|      0|}
 2931|       |
 2932|       |
 2933|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
 2934|      0|{
 2935|      0|    if (item == NULL)
 2936|      0|    {
 2937|      0|        return false;
 2938|      0|    }
 2939|       |
 2940|      0|    return (item->type & (cJSON_True | cJSON_False)) != 0;
 2941|      0|}
 2942|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
 2943|      0|{
 2944|      0|    if (item == NULL)
 2945|      0|    {
 2946|      0|        return false;
 2947|      0|    }
 2948|       |
 2949|      0|    return (item->type & 0xFF) == cJSON_NULL;
 2950|      0|}
 2951|       |
 2952|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
 2953|      0|{
 2954|      0|    if (item == NULL)
 2955|      0|    {
 2956|      0|        return false;
 2957|      0|    }
 2958|       |
 2959|      0|    return (item->type & 0xFF) == cJSON_Number;
 2960|      0|}
 2961|       |
 2962|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
 2963|      0|{
 2964|      0|    if (item == NULL)
 2965|      0|    {
 2966|      0|        return false;
 2967|      0|    }
 2968|       |
 2969|      0|    return (item->type & 0xFF) == cJSON_String;
 2970|      0|}
 2971|       |
 2972|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
 2973|      0|{
 2974|      0|    if (item == NULL)
 2975|      0|    {
 2976|      0|        return false;
 2977|      0|    }
 2978|       |
 2979|      0|    return (item->type & 0xFF) == cJSON_Array;
 2980|      0|}
 2981|       |
 2982|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
 2983|      0|{
 2984|      0|    if (item == NULL)
 2985|      0|    {
 2986|      0|        return false;
 2987|      0|    }
 2988|       |
 2989|      0|    return (item->type & 0xFF) == cJSON_Object;
 2990|      0|}
 2991|       |
 2992|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
 2993|      0|{
 2994|      0|    if (item == NULL)
 2995|      0|    {
 2996|      0|        return false;
 2997|      0|    }
 2998|       |
 2999|      0|    return (item->type & 0xFF) == cJSON_Raw;
 3000|      0|}
 3001|       |
 3002|       |CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
 3003|      0|{
 3004|      0|    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))
 3005|      0|    {
 3006|      0|        return false;
 3007|      0|    }
 3008|       |
 3009|       |    /* check if type is valid */
 3010|      0|    switch (a->type & 0xFF)
 3011|      0|    {
 3012|      0|        case cJSON_False:
 3013|      0|        case cJSON_True:
 3014|      0|        case cJSON_NULL:
 3015|      0|        case cJSON_Number:
 3016|      0|        case cJSON_String:
 3017|      0|        case cJSON_Raw:
 3018|      0|        case cJSON_Array:
 3019|      0|        case cJSON_Object:
 3020|      0|            break;
 3021|       |
 3022|      0|        default:
 3023|      0|            return false;
 3024|      0|    }
 3025|       |
 3026|       |    /* identical objects are equal */
 3027|      0|    if (a == b)
 3028|      0|    {
 3029|      0|        return true;
 3030|      0|    }
 3031|       |
 3032|      0|    switch (a->type & 0xFF)
 3033|      0|    {
 3034|       |        /* in these cases and equal type is enough */
 3035|      0|        case cJSON_False:
 3036|      0|        case cJSON_True:
 3037|      0|        case cJSON_NULL:
 3038|      0|            return true;
 3039|       |
 3040|      0|        case cJSON_Number:
 3041|      0|            if (compare_double(a->valuedouble, b->valuedouble))
 3042|      0|            {
 3043|      0|                return true;
 3044|      0|            }
 3045|      0|            return false;
 3046|       |
 3047|      0|        case cJSON_String:
 3048|      0|        case cJSON_Raw:
 3049|      0|            if ((a->valuestring == NULL) || (b->valuestring == NULL))
 3050|      0|            {
 3051|      0|                return false;
 3052|      0|            }
 3053|      0|            if (strcmp(a->valuestring, b->valuestring) == 0)
 3054|      0|            {
 3055|      0|                return true;
 3056|      0|            }
 3057|       |
 3058|      0|            return false;
 3059|       |
 3060|      0|        case cJSON_Array:
 3061|      0|        {
 3062|      0|            cJSON *a_element = a->child;
 3063|      0|            cJSON *b_element = b->child;
 3064|       |
 3065|      0|            for (; (a_element != NULL) && (b_element != NULL);)
 3066|      0|            {
 3067|      0|                if (!cJSON_Compare(a_element, b_element, case_sensitive))
 3068|      0|                {
 3069|      0|                    return false;
 3070|      0|                }
 3071|       |
 3072|      0|                a_element = a_element->next;
 3073|      0|                b_element = b_element->next;
 3074|      0|            }
 3075|       |
 3076|       |            /* one of the arrays is longer than the other */
 3077|      0|            if (a_element != b_element) {
 3078|      0|                return false;
 3079|      0|            }
 3080|       |
 3081|      0|            return true;
 3082|      0|        }
 3083|       |
 3084|      0|        case cJSON_Object:
 3085|      0|        {
 3086|      0|            cJSON *a_element = NULL;
 3087|      0|            cJSON *b_element = NULL;
 3088|      0|            cJSON_ArrayForEach(a_element, a)
 3089|      0|            {
 3090|       |                /* TODO This has O(n^2) runtime, which is horrible! */
 3091|      0|                b_element = get_object_item(b, a_element->string, case_sensitive);
 3092|      0|                if (b_element == NULL)
 3093|      0|                {
 3094|      0|                    return false;
 3095|      0|                }
 3096|       |
 3097|      0|                if (!cJSON_Compare(a_element, b_element, case_sensitive))
 3098|      0|                {
 3099|      0|                    return false;
 3100|      0|                }
 3101|      0|            }
 3102|       |
 3103|       |            /* doing this twice, once on a and b to prevent true comparison if a subset of b
 3104|       |             * TODO: Do this the proper way, this is just a fix for now */
 3105|      0|            cJSON_ArrayForEach(b_element, b)
 3106|      0|            {
 3107|      0|                a_element = get_object_item(a, b_element->string, case_sensitive);
 3108|      0|                if (a_element == NULL)
 3109|      0|                {
 3110|      0|                    return false;
 3111|      0|                }
 3112|       |
 3113|      0|                if (!cJSON_Compare(b_element, a_element, case_sensitive))
 3114|      0|                {
 3115|      0|                    return false;
 3116|      0|                }
 3117|      0|            }
 3118|       |
 3119|      0|            return true;
 3120|      0|        }
 3121|       |
 3122|      0|        default:
 3123|      0|            return false;
 3124|      0|    }
 3125|      0|}
 3126|       |
 3127|       |CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
 3128|      0|{
 3129|      0|    return global_hooks.allocate(size);
 3130|      0|}
 3131|       |
 3132|       |CJSON_PUBLIC(void) cJSON_free(void *object)
 3133|      0|{
 3134|      0|    global_hooks.deallocate(object);
 3135|      0|}

/home/s22100141/AFLplusplus-experimental/cJSON/cJSON.h:
    1|       |/*
    2|       |  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
    3|       |
    4|       |  Permission is hereby granted, free of charge, to any person obtaining a copy
    5|       |  of this software and associated documentation files (the "Software"), to deal
    6|       |  in the Software without restriction, including without limitation the rights
    7|       |  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    8|       |  copies of the Software, and to permit persons to whom the Software is
    9|       |  furnished to do so, subject to the following conditions:
   10|       |
   11|       |  The above copyright notice and this permission notice shall be included in
   12|       |  all copies or substantial portions of the Software.
   13|       |
   14|       |  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   15|       |  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   16|       |  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   17|       |  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   18|       |  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   19|       |  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   20|       |  THE SOFTWARE.
   21|       |*/
   22|       |
   23|       |#ifndef cJSON__h
   24|       |#define cJSON__h
   25|       |
   26|       |#ifdef __cplusplus
   27|       |extern "C"
   28|       |{
   29|       |#endif
   30|       |
   31|       |#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))
   32|       |#define __WINDOWS__
   33|       |#endif
   34|       |
   35|       |#ifdef __WINDOWS__
   36|       |
   37|       |/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 3 define options:
   38|       |
   39|       |CJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols
   40|       |CJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)
   41|       |CJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol
   42|       |
   43|       |For *nix builds that support visibility attribute, you can define similar behavior by
   44|       |
   45|       |setting default visibility to hidden by adding
   46|       |-fvisibility=hidden (for gcc)
   47|       |or
   48|       |-xldscope=hidden (for sun cc)
   49|       |to CFLAGS
   50|       |
   51|       |then using the CJSON_API_VISIBILITY flag to "export" the same symbols the way CJSON_EXPORT_SYMBOLS does
   52|       |
   53|       |*/
   54|       |
   55|       |#define CJSON_CDECL __cdecl
   56|       |#define CJSON_STDCALL __stdcall
   57|       |
   58|       |/* export symbols by default, this is necessary for copy pasting the C and header file */
   59|       |#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)
   60|       |#define CJSON_EXPORT_SYMBOLS
   61|       |#endif
   62|       |
   63|       |#if defined(CJSON_HIDE_SYMBOLS)
   64|       |#define CJSON_PUBLIC(type)   type CJSON_STDCALL
   65|       |#elif defined(CJSON_EXPORT_SYMBOLS)
   66|       |#define CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL
   67|       |#elif defined(CJSON_IMPORT_SYMBOLS)
   68|       |#define CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL
   69|       |#endif
   70|       |#else /* !__WINDOWS__ */
   71|       |#define CJSON_CDECL
   72|       |#define CJSON_STDCALL
   73|       |
   74|       |#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)
   75|       |#define CJSON_PUBLIC(type)   __attribute__((visibility("default"))) type
   76|       |#else
   77|       |#define CJSON_PUBLIC(type) type
   78|       |#endif
   79|       |#endif
   80|       |
   81|       |/* project version */
   82|      0|#define CJSON_VERSION_MAJOR 1
   83|      0|#define CJSON_VERSION_MINOR 7
   84|      0|#define CJSON_VERSION_PATCH 17
   85|       |
   86|       |#include <stddef.h>
   87|       |
   88|       |/* cJSON Types: */
   89|      0|#define cJSON_Invalid (0)
   90|    489|#define cJSON_False  (1 << 0)
   91|    384|#define cJSON_True   (1 << 1)
   92|    295|#define cJSON_NULL   (1 << 2)
   93|  11.6k|#define cJSON_Number (1 << 3)
   94|  34.1k|#define cJSON_String (1 << 4)
   95|  4.04k|#define cJSON_Array  (1 << 5)
   96|  5.35k|#define cJSON_Object (1 << 6)
   97|      0|#define cJSON_Raw    (1 << 7) /* raw json */
   98|       |
   99|  59.3k|#define cJSON_IsReference 256
  100|  29.6k|#define cJSON_StringIsConst 512
  101|       |
  102|       |/* The cJSON structure: */
  103|       |typedef struct cJSON
  104|       |{
  105|       |    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
  106|       |    struct cJSON *next;
  107|       |    struct cJSON *prev;
  108|       |    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
  109|       |    struct cJSON *child;
  110|       |
  111|       |    /* The type of the item, as above. */
  112|       |    int type;
  113|       |
  114|       |    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
  115|       |    char *valuestring;
  116|       |    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
  117|       |    int valueint;
  118|       |    /* The item's number, if type==cJSON_Number */
  119|       |    double valuedouble;
  120|       |
  121|       |    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
  122|       |    char *string;
  123|       |} cJSON;
  124|       |
  125|       |typedef struct cJSON_Hooks
  126|       |{
  127|       |      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */
  128|       |      void *(CJSON_CDECL *malloc_fn)(size_t sz);
  129|       |      void (CJSON_CDECL *free_fn)(void *ptr);
  130|       |} cJSON_Hooks;
  131|       |
  132|       |typedef int cJSON_bool;
  133|       |
  134|       |/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.
  135|       | * This is to prevent stack overflows. */
  136|       |#ifndef CJSON_NESTING_LIMIT
  137|  10.7k|#define CJSON_NESTING_LIMIT 1000
  138|       |#endif
  139|       |
  140|       |/* returns the version of cJSON as a string */
  141|       |CJSON_PUBLIC(const char*) cJSON_Version(void);
  142|       |
  143|       |/* Supply malloc, realloc and free functions to cJSON */
  144|       |CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);
  145|       |
  146|       |/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */
  147|       |/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */
  148|       |CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
  149|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);
  150|       |/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
  151|       |/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
  152|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
  153|       |CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);
  154|       |
  155|       |/* Render a cJSON entity to text for transfer/storage. */
  156|       |CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
  157|       |/* Render a cJSON entity to text for transfer/storage without any formatting. */
  158|       |CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
  159|       |/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
  160|       |CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
  161|       |/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
  162|       |/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
  163|       |CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
  164|       |/* Delete a cJSON entity and all subentities. */
  165|       |CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);
  166|       |
  167|       |/* Returns the number of items in an array (or object). */
  168|       |CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
  169|       |/* Retrieve item number "index" from array "array". Returns NULL if unsuccessful. */
  170|       |CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
  171|       |/* Get item "string" from object. Case insensitive. */
  172|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
  173|       |CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
  174|       |CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
  175|       |/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
  176|       |CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);
  177|       |
  178|       |/* Check item type and return its value */
  179|       |CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);
  180|       |CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);
  181|       |
  182|       |/* These functions check the type of an item */
  183|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
  184|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
  185|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
  186|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
  187|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
  188|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
  189|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
  190|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
  191|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
  192|       |CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);
  193|       |
  194|       |/* These calls create a cJSON item of the appropriate type. */
  195|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
  196|       |CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
  197|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
  198|       |CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
  199|       |CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
  200|       |CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
  201|       |/* raw json */
  202|       |CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);
  203|       |CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);
  204|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);
  205|       |
  206|       |/* Create a string where valuestring references a string so
  207|       | * it will not be freed by cJSON_Delete */
  208|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
  209|       |/* Create an object/array that only references it's elements so
  210|       | * they will not be freed by cJSON_Delete */
  211|       |CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
  212|       |CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);
  213|       |
  214|       |/* These utilities create an Array of count items.
  215|       | * The parameter count cannot be greater than the number of elements in the number array, otherwise array access will be out of bounds.*/
  216|       |CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
  217|       |CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
  218|       |CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
  219|       |CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);
  220|       |
  221|       |/* Append item to the specified array/object. */
  222|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);
  223|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
  224|       |/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.
  225|       | * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
  226|       | * writing to `item->string` */
  227|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
  228|       |/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
  229|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
  230|       |CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);
  231|       |
  232|       |/* Remove/Detach items from Arrays/Objects. */
  233|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
  234|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);
  235|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
  236|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);
  237|       |CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
  238|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
  239|       |CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);
  240|       |
  241|       |/* Update array items. */
  242|       |CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
  243|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
  244|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
  245|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
  246|       |CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);
  247|       |
  248|       |/* Duplicate a cJSON item */
  249|       |CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
  250|       |/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
  251|       | * need to be released. With recurse!=0, it will duplicate any children connected to the item.
  252|       | * The item->next and ->prev pointers are always zero on return from Duplicate. */
  253|       |/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
  254|       | * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
  255|       |CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);
  256|       |
  257|       |/* Minify a strings, remove blank characters(such as ' ', '\t', '\r', '\n') from strings.
  258|       | * The input pointer json cannot point to a read-only address area, such as a string constant, 
  259|       | * but should point to a readable and writable address area. */
  260|       |CJSON_PUBLIC(void) cJSON_Minify(char *json);
  261|       |
  262|       |/* Helper functions for creating and adding items to an object at the same time.
  263|       | * They return the added item or NULL on failure. */
  264|       |CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);
  265|       |CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);
  266|       |CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);
  267|       |CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
  268|       |CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
  269|       |CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
  270|       |CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
  271|       |CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);
  272|       |CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);
  273|       |
  274|       |/* When assigning an integer value, it needs to be propagated to valuedouble too. */
  275|       |#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
  276|       |/* helper for the cJSON_SetNumberValue macro */
  277|       |CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);
  278|       |#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))
  279|       |/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */
  280|       |CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);
  281|       |
  282|       |/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/
  283|       |#define cJSON_SetBoolValue(object, boolValue) ( \
  284|       |    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \
  285|       |    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \
  286|       |    cJSON_Invalid\
  287|       |)
  288|       |
  289|       |/* Macro for iterating over an array or object */
  290|      0|#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)
  291|       |
  292|       |/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */
  293|       |CJSON_PUBLIC(void *) cJSON_malloc(size_t size);
  294|       |CJSON_PUBLIC(void) cJSON_free(void *object);
  295|       |
  296|       |#ifdef __cplusplus
  297|       |}
  298|       |#endif
  299|       |
  300|       |#endif

/home/s22100141/AFLplusplus-experimental/cJSON/fuzzing/afl.c:
    1|       |/*
    2|       |  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
    3|       |
    4|       |  Permission is hereby granted, free of charge, to any person obtaining a copy
    5|       |  of this software and associated documentation files (the "Software"), to deal
    6|       |  in the Software without restriction, including without limitation the rights
    7|       |  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    8|       |  copies of the Software, and to permit persons to whom the Software is
    9|       |  furnished to do so, subject to the following conditions:
   10|       |
   11|       |  The above copyright notice and this permission notice shall be included in
   12|       |  all copies or substantial portions of the Software.
   13|       |
   14|       |  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   15|       |  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   16|       |  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   17|       |  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   18|       |  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   19|       |  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   20|       |  THE SOFTWARE.
   21|       |*/
   22|       |
   23|       |#include <stdio.h>
   24|       |#include <stdlib.h>
   25|       |#include <string.h>
   26|       |
   27|       |#include "../cJSON.h"
   28|       |
   29|       |static char *read_file(const char *filename)
   30|  2.02k|{
   31|  2.02k|    FILE *file = NULL;
   32|  2.02k|    long length = 0;
   33|  2.02k|    char *content = NULL;
   34|  2.02k|    size_t read_chars = 0;
   35|       |
   36|       |    /* open in read binary mode */
   37|  2.02k|    file = fopen(filename, "rb");
   38|  2.02k|    if (file == NULL)
   39|      0|    {
   40|      0|        goto cleanup;
   41|      0|    }
   42|       |
   43|       |    /* get the length */
   44|  2.02k|    if (fseek(file, 0, SEEK_END) != 0)
   45|      0|    {
   46|      0|        goto cleanup;
   47|      0|    }
   48|  2.02k|    length = ftell(file);
   49|  2.02k|    if (length < 0)
   50|      0|    {
   51|      0|        goto cleanup;
   52|      0|    }
   53|  2.02k|    if (fseek(file, 0, SEEK_SET) != 0)
   54|      0|    {
   55|      0|        goto cleanup;
   56|      0|    }
   57|       |
   58|       |    /* allocate content buffer */
   59|  2.02k|    content = (char*)malloc((size_t)length + sizeof(""));
   60|  2.02k|    if (content == NULL)
   61|      0|    {
   62|      0|        goto cleanup;
   63|      0|    }
   64|       |
   65|       |    /* read the file into memory */
   66|  2.02k|    read_chars = fread(content, sizeof(char), (size_t)length, file);
   67|  2.02k|    if ((long)read_chars != length)
   68|      0|    {
   69|      0|        free(content);
   70|      0|        content = NULL;
   71|      0|        goto cleanup;
   72|      0|    }
   73|  2.02k|    content[read_chars] = '\0';
   74|       |
   75|       |
   76|  2.02k|cleanup:
   77|  2.02k|    if (file != NULL)
   78|  2.02k|    {
   79|  2.02k|        fclose(file);
   80|  2.02k|    }
   81|       |
   82|  2.02k|    return content;
   83|  2.02k|}
   84|       |
   85|       |int main(int argc, char** argv)
   86|  2.02k|{
   87|  2.02k|    const char *filename = NULL;
   88|  2.02k|    cJSON *item = NULL;
   89|  2.02k|    char *json = NULL;
   90|  2.02k|    int status = EXIT_FAILURE;
   91|  2.02k|    char *printed_json = NULL;
   92|       |
   93|  2.02k|    if ((argc < 2) || (argc > 3))
   94|      0|    {
   95|      0|        printf("Usage:\n");
   96|      0|        printf("%s input_file [enable_printing]\n", argv[0]);
   97|      0|        printf("\t input_file: file containing the test data\n");
   98|      0|        printf("\t enable_printing: print after parsing, 'yes' or 'no', defaults to 'no'\n");
   99|      0|        goto cleanup;
  100|      0|    }
  101|       |
  102|  2.02k|    filename = argv[1];
  103|       |
  104|       |#if __AFL_HAVE_MANUAL_CONTROL
  105|       |    while (__AFL_LOOP(1000))
  106|       |    {
  107|       |#endif
  108|  2.02k|    status = EXIT_SUCCESS;
  109|       |
  110|  2.02k|    json = read_file(filename);
  111|  2.02k|    if ((json == NULL) || (json[0] == '\0') || (json[1] == '\0'))
  112|     10|    {
  113|     10|        status = EXIT_FAILURE;
  114|     10|        goto cleanup;
  115|     10|    }
  116|  2.01k|    item = cJSON_Parse(json + 2);
  117|  2.01k|    if (item == NULL)
  118|    947|    {
  119|    947|        goto cleanup;
  120|    947|    }
  121|  1.06k|   char yes[5] = "yes";
  122|  1.06k|   argv[2] = yes;
  123|  1.06k|   argc=3;
  124|  1.06k|    if ((argc == 3) && (strncmp(argv[2], "yes", 3) == 0))
  125|  1.06k|    {
  126|  1.06k|        int do_format = 0;
  127|  1.06k|        if (json[1] == 'f')
  128|    614|        {
  129|    614|            do_format = 1;
  130|    614|        }
  131|       |
  132|  1.06k|        if (json[0] == 'b')
  133|    798|        {
  134|       |            /* buffered printing */
  135|    798|            printed_json = cJSON_PrintBuffered(item, 1, do_format);
  136|    798|        }
  137|    267|        else
  138|    267|        {
  139|       |            /* unbuffered printing */
  140|    267|            if (do_format)
  141|     27|            {
  142|     27|                printed_json = cJSON_Print(item);
  143|     27|            }
  144|    240|            else
  145|    240|            {
  146|    240|                printed_json = cJSON_PrintUnformatted(item);
  147|    240|            }
  148|    267|        }
  149|  1.06k|        if (printed_json == NULL)
  150|      0|        {
  151|      0|            status = EXIT_FAILURE;
  152|      0|            goto cleanup;
  153|      0|        }
  154|  1.06k|        printf("%s\n", printed_json);
  155|  1.06k|    }
  156|       |
  157|  2.02k|cleanup:
  158|  2.02k|    if (item != NULL)
  159|  1.06k|    {
  160|  1.06k|        cJSON_Delete(item);
  161|  1.06k|        item = NULL;
  162|  1.06k|    }
  163|  2.02k|    if (json != NULL)
  164|  2.02k|    {
  165|  2.02k|        free(json);
  166|  2.02k|        json = NULL;
  167|  2.02k|    }
  168|  2.02k|    if (printed_json != NULL)
  169|  1.06k|    {
  170|  1.06k|        free(printed_json);
  171|  1.06k|        printed_json = NULL;
  172|  1.06k|    }
  173|       |#if __AFL_HAVE_MANUAL_CONTROL
  174|       |    }
  175|       |#endif
  176|       |
  177|  2.02k|    return status;
  178|  1.06k|}

